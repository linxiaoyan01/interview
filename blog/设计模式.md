---
title: 设计模式
categories: 设计模式
tags: [设计模式]
---

# 软件设计模式

## 软件设计模式介绍

- 掌握软件设计的六大原则
- 掌握创建型模式、工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 掌握结构型模式、适配器模式、桥接模式、装饰器模式、代理模式、组合模式、外观模式、享元模式
- 掌握行为型模式责任链模式、迭代器模式、观察者模式、状态模式、策略模式、模板模式 、备忘录模式、命令模式等
- 掌握20多种设计模式的应用场景、优点、缺点和需求案例实战
- 掌握多个源码里面设计模式的应用和面试题

# 不可不知道的设计模式精髓

## 设计模式的六大原则

- 设计模式是站在设计原则的基础之上的，所以在学习设计模式之前，有必要对这些设计原则先做一下了解
- 软件设计开发原则
  - 为了让的代码更好重用性，可读性，可靠性，可维护性
  - 诞生出了很多软件设计的原则，这6大设计原则是我们要掌握的
  - 将六大原则的英文首字母拼在一起就是SOLID（稳定的），所以也称之为SOLID原则

- 单一职责原则

  - 一个类只负责一个功能领域中的相应职责，就一个类而言，应该只有一个引起它变化的原因
  - 是实现**高内聚、低耦合**的指导方针
  - 解释：
    - 高内聚
      - 尽可能类的每个成员方法只完成一件事（最大限度的聚合）
      - 模块内部的代码， 相互之间的联系越强，内聚就越高， 模块的独立性就越好
    - 低耦合: 减少类内部，一个成员方法调用另一个成员方法, 不要有牵一发动全身

   

- 开闭原则

  - 对扩展开放，对修改关闭，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果

   

- 里氏替换原则LSP

  - 任何基类可以出现的地方，子类一定可以出现
  - 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
  - controller->service->dao

   

- 依赖倒转原则

  - 是开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体
  - 高层模块不应该依赖低层模块，二者都应该依赖其抽象

   

- 接口隔离原则

  - 客户端不应该依赖那些它不需要的接口
  - 使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度

   

- 迪米特法则

  - 最少知道原则，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立
  - 类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及
  - 通过引入一个合理的第三者来降低现有对象之间的耦合度

## 设计模式简介

- 由来：是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的
- 好处：为了重用代码、让代码更容易被他人理解、保证代码可靠性
- 坏处：对不熟悉设计模式的同学，看起来更绕更难理解
- 什么是GOF（ Gang of Four）

```
在 1994 年，由 四位作者合称 GOF（全拼 Gang of Four）四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software. 他们所提出的设计模式主要是基于以下的面向对象设计原则。

1)对接口编程而不是对实现编程。
2)优先使用对象组合而不是继承
```

- 常见的三大设计模式分类

  - 创建型模式

    提供了一种在创建对象的同时隐藏创建逻辑的方式，使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活

    ```
    常用：工厂模式、抽象工厂模式、单例模式、建造者模式
    不常用：原型模式
    ```

  - 结构型模式

    关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式

    ```
    常用：适配器模式、桥接模式、装饰器模式、代理模式
    不常用：组合模式、外观模式、享元模式、
    ```

  - 行为型模式

  - 特别关注对象之间的通信

    ```
    常用：责任链模式、迭代器模式、观察者模式、状态模式、策略模式、模板模式
      
    不常用：备忘录模式、命令模式
      
    几乎不用：访问者模式、中介者模式、解释器模式
    ```

# 创建型设计模式-单例设计模式和应用

## 单例设计模式

- 单例设计模式：
  - 这个是最简单的设计模式，所以拎出来第一个讲, 但事实却不是。
  - 单例意思只包含一个对象被称为单例的特殊类
  - 通过单例模式可以保证系统中，应用该模式的类只有一个对象实例
- 使用场景
  - 业务系统全局只需要一个对象实例，比如发号器、redis连接对象等
  - Spring IOC容器中的bean默认就是单例
  - spring boot 中的controller、service、dao层中通过@autowire的依赖注入对象默认都是单例的
- 分类：
  - 懒汉：就是所谓的懒加载，延迟创建对象
  - 饿汉：与懒汉相反，提前创建对象
- 实现步骤
  - 私有化构造函数
  - 提供获取单例的方法

## 单例模式中的懒汉实现+双重检查锁定+内存模型

```java
package singleton;
public class SingletonLazy {

    //private static SingletonLazy instance;

    /**
     * 构造函数私有化
     */
    private SingletonLazy(){}

    /**
     * 单例对象的方法
     */
    public void process(){
        System.out.println("方法调用成功");
    }

    /**
     * 第一种方式
     * 对外暴露一个方法获取类的对象
     * 线程不安全
     */
//    public static SingletonLazy getInstance(){
//
//        if(instance == null){
//            instance = new SingletonLazy();
//        }
//        return instance;
//    }

    /**
     * 第二种
     * 通过加锁 synchronized 保证单例
     * 有很大的性能开销
     * 解决办法：锁粒度不要那么大
     */
//    public static synchronized SingletonLazy getInstance(){
//
//        if(instance == null){
//            instance = new SingletonLazy();
//        }
//        return instance;
//    }

    /**
     * 第三种
     * @return
     */
//    public static SingletonLazy getInstance(){
//
//        if(instance == null){
//            //A,B
//            synchronized (SingletonLazy.class){
//                instance = new SingletonLazy();
//            }
//        }
//        return instance;
//    }
    /**
     * DCL 双重检查锁定 Double Checked Locking
     * 这个是否安全？
     * instance = new SingletonLazy(); 不是原子性操作
     * 指令重排
     * 1、分配空间给内存
     * 2、在空间内创建对象
     * 3、将对象赋值给引用
     * 假如线程 1-》3 -》2 顺序，会把值写回内存，其他线程就会读取到instance最新的值，但是这个是不完全的对象
     */
//    public static SingletonLazy getInstance(){
//
//        if(instance == null){
//            //A,B
//            synchronized (SingletonLazy.class){
//                if(instance == null){
//                    instance = new SingletonLazy();
//                }
//
//            }
//        }
//        return instance;
//    }

    /**
     * volatile 是java 提供的关键词,可以禁止指令重排
     * @return
     */
    private static volatile SingletonLazy instance;
    public static SingletonLazy getInstance(){
        //第一重检查
        if(instance == null){
            //A,B
            synchronized (SingletonLazy.class){
                //第二重检查
                if(instance == null){
                    instance = new SingletonLazy();
                }

            }
        }
        return instance;
    }
}
```

- 主函数调用

```java
public class Main {
    public static void main(String[] args) {
        //单例模式
        //SingletonLazy.getInstance().process();
        //SingletonHungry.getInstance().process();
}
```

## 单例模式中的饿汉实现和选择问题

- 饿汉方式：提前创建好对象

  ```java
  package singleton;
  public class SingletonHungry {
      private static SingletonHungry instance = new SingletonHungry();
      private SingletonHungry(){}
      public static SingletonHungry getInstance(){
          return instance;
      }
      public void process(){
          System.out.println("方法调用成功");
      }
  }
  ```

- 优点：实现简单，没有多线程同步问题
- 缺点：不管有没使用，instance对象一直占着这段内存
- 如何选择：
  - 如果对象不大，且创建不复杂，直接用饿汉的方式即可
  - 其他情况则采用懒汉实现方式

## JDK源码里面的单例设计模式

- JDK中Runtime类 饿汉方式

  ![image-20200925164736200](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200925164736200.png)

- JDK中Desktop类 懒汉方式

  ![image-20200925164706506](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200925164706506.png)

# 创建型设计模式-工厂模式和应用

## 原生社会过渡-常见的工厂设计模式

- 工厂模式介绍：
  - 它提供了一种创建对象的最佳方式，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象
- 例子：
  - 需要购买一辆车，不用管车辆如何组装，且可以购买不同类型的比如轿车、SUV、跑车，直接去4s店购买就行（4s店就是工厂）
  - 工厂生产电脑，除了A品牌、还可以生产B、C、D品牌电脑
  - 业务开发中，支付很常见，里面有统一下单和支付接口，具体的支付实现可以微信、支付宝、银行卡等

- 工厂模式有 3 种不同的实现方式
  - 简单工厂模式：通过传入相关的类型来返回相应的类,这种方式比较单 一,可扩展性相对较差;
  - 工厂方法模式：通过实现类实现相应的方法来决定相应的返回结果,这种方式的可扩展性比较强；
  - 抽象工厂模式：基于上述两种模式的拓展，且支持细化产品
- 应用场景：
  - 解耦：分离职责，把复杂对象的创建和使用的过程分开
  - 复用代码，降低维护成本：
    - 如果对象创建复杂且多处需用到，如果每处都进行编写，则很多重复代码，如果业务逻辑发生了改变，需用四处修改；
    - 使用工厂模式统一创建，则只要修改工厂类即可，降低成本

##  电商支付应用案例-简单工厂模式实践指南

- 简单工厂模式
  - 又称静态工厂方法, 可以根据参数的不同返回不同类的实例，专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
  - 由于工厂方法是静态方法，可通过类名直接调用，而且只需要传入简单的参数即可 
- 核心组成
  - Factory：工厂类，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑
  - IProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，描述所有实例所共有的公共接口
  - Product：具体产品类，是简单工厂模式的创建目标

- 实现步骤
  - 创建抽象产品类，里面有产品的抽象方法，由具体的产品类去实现
  - 创建具体产品类，继承了他们的父类，并实现具体方法
  - 创建工厂类，提供了一个静态方法createXXX用来生产产品，只需要传入你想产品名称

- 优点：
  - 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
- 缺点
  - 工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背
  - 即开闭原则（Open Close Principle）对扩展开放，对修改关闭，程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果
  - 将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度，不利于系统的扩展和维护，创建简单对象就不用模式

```java
//创建接口Pay
package factory.simple;
public interface Pay {
    void unifiedPay();
}
//AliPay类实现Pay接口
public class AliPay implements Pay {
    @Override
    public void unifiedPay() {
        System.out.println("支付宝支付 统一下单接口");
    }
}
//WechatPay类实现Pay接口
public class WechatPay implements Pay {

    @Override
    public void unifiedPay() {
        System.out.println("微信支付 统一下单接口");
    }
}
//SimplePayFactory类
public class SimplePayFactory {
    public static Pay createPay(String payType){
        if(payType == null){
            return null;
        }else if(payType.equalsIgnoreCase("WECHAT_PAY")){
            return new WechatPay();
        }else if(payType.equalsIgnoreCase("ALI_PAY")){
            return new AliPay();
        }
        return null;
    }
}
//main类
Pay pay = SimplePayFactory.createPay("WECHAT_PAY");
pay.unifiedPay();
```

## 工厂设计模式实践指南-工厂方法模式

- 工厂方法模式
  - 又称工厂模式，是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则
  - 通过工厂父类定义负责创建产品的公共接口，通过子类来确定所需要创建的类型
  - 相比简单工厂而言，此种方法具有更多的可扩展性和复用性，同时也增强了代码的可读性
  - 将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化哪一个类。
- 核心组成
  - IProduct：抽象产品类，描述所有实例所共有的公共接口
  - Product：具体产品类，实现抽象产品类的接口，工厂类创建对象，如果有多个需要定义多个
  - IFactory：抽象工厂类，描述具体工厂的公共接口
  - Factory：具体工厂类，实现创建产品类对象，实现抽象工厂类的接口，如果有多个需要定义多个

![image-20210510224849967](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510224906.png)

```java
//创建接口Pay
package factory.method;
public interface Pay {
    void unifiedPay();
}
//AliPay类实现Pay接口
public class AliPay implements Pay {
    @Override
    public void unifiedPay() {
        System.out.println("支付宝支付 统一下单接口");
    }
}
//WechatPay类实现Pay接口
public class WechatPay implements Pay {
    @Override
    public void unifiedPay() {
        System.out.println("微信支付 统一下单接口");
    }
}
//PayFactory接口
public interface PayFactory {
    Pay getPay();
}
//AliPayFactory类实现了PayFactory接口
public class AliPayFactory implements  PayFactory{
    @Override
    public Pay getPay() {
        return new AliPay();
    }
}
//WechatPayFactory类实现了PayFactory接口
public class WechatPayFactory implements PayFactory{
    @Override
    public Pay getPay() {
        return new WechatPay();
    }
}
//main类
PayFactory aliPayFactory = new AliPayFactory();
Pay aliPay = aliPayFactory.getPay();
aliPay.unifiedPay();
PayFactory wechatFactory = new WechatPayFactory();
Pay wechatPay = wechatFactory.getPay();
wechatPay.unifiedPay();
```

## 工厂设计模式实践指南- 抽象工厂方法模式

- 工厂模式有 3 种不同的实现方式
  - 简单工厂模式：通过传入相关的类型来返回相应的类,这种方式比较单 一,可扩展性相对较差;
  - 工厂方法模式：通过实现类实现相应的方法来决定相应的返回结果,这种方式的可扩展性比较强；
  - **抽象工厂模式：基于上述两种模式的拓展，是工厂方法模式的升级版，当需要创建的产品有多个产品线时使用抽象工厂模式是比较好的选择**
  - 抽象工厂模式在 Spring 中应用得最为广泛的一种设计模式

- 背景
  - 工厂方法模式引入工厂等级结构，解决了简单工厂模式中工厂类职责过重的问题
  - 但工厂方法模式中每个工厂只创建一类具体类的对象，后续发展可能会导致工厂类过多，因此将一些相关的具体类组成一个“具体类族”，由同一个工厂来统一生产，强调的是一系列相关的产品对象！！！

![image-20210510225711526](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510225714.png)

- 实现步骤

```
1、定义两个接口 Pay、Refund

2、创建具体的Pay产品、创建具体的Refund产品

3、创建抽象工厂 OrderFactory 接口
  里面两个方法 createPay/createRefund

4、创建支付宝产品族AliOderFactory，实现OrderFactory抽象工厂

5、创建微信支付产品族WechatOderFactory，实现OrderFactory抽象工厂

6、定义一个超级工厂创造器，通过传递参数获取对应的工厂
```

![image-20210510225804951](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510225807.png)

```java
/**
 * 超级工厂，定义同个产品族的其他相关子工厂
 */
public interface OrderFactory {
    PayFactory createPay();
    RefundFactory createRefund();
}

//产品族工厂的产品，可以不叫Factory，看公司团队规范，比如类名叫 IPay 也可以的
public interface PayFactory {
    /**
     * 统一下单
     */
    void unifiedorder();
}
public interface RefundFactory {
    void refund();
}

//产品族工厂
public class AliOrderFactory implements OrderFactory {

    @Override
    public PayFactory createPay() {
        return new AliPay();
    }
    @Override
    public RefundFactory createRefund() {
        return new AliRefund();
    }
}

//具体产品
public class AliPay implements PayFactory {
    @Override
    public void unifiedorder() {
        System.out.println("支付宝支付 统一下单接口");
    }
}
public class AliRefund implements RefundFactory {
    @Override
    public void refund() {
        System.out.println("支付宝退款");
    }
}
//超级工厂生产器，传参生产对应的子工厂
public class FactoryProducer {
    public static OrderFactory getFactory(String type) {
        if (type.equalsIgnoreCase("WECHAT")) {
            return new WechatOrderFactory();
        } else if (type.equalsIgnoreCase("ALI")) {
            return new AliOrderFactory();
        }
        return null;
    }
}
//Main函数使用
OrderFactory orderFactory = FactoryProducer.getFactory("ALI");
orderFactory.createPay().unifiedorder();
orderFactory.createRefund().refund();
```

- 工厂方法模式和抽象工厂方法模式
  - 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，抽象工厂模式退化成工厂方法模式
- 优点
  - 当一个产品族中的多个对象被设计成一起工作时，它能保证使用方始终只使用同一个产品族中的对象
  - 产品等级结构扩展容易，如果需要增加多一个产品等级，只需要增加新的工厂类和产品类即可, 比如增加银行支付、退款
- 缺点
  - 产品族扩展困难，要增加一个系列的某一产品，既要在抽象的工厂和抽象产品里修改代码，不是很符合开闭原则
  - 增加了系统的抽象性和理解难度

# 创建型设计模式 建造者+原型模式的应用场景

## 创建型设计模式-Prototype原型设计模式实战

- 原型设计模式Prototype

  - 是一种对象创建型模式，使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，主要用于创建重复的对象，同时又能保证性能
  - 工作原理是将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程
  - 应该是最简单的设计模式了，实现一个接口，重写一个方法即完成了原型模式

- 核心组成

  - **Prototype**: 声明克隆方法的接口,是所有具体原型类的公共父类，Cloneable接口
  - **ConcretePrototype** : 具体原型类
  - **Client**: 让一个原型对象克隆自身从而创建一个新的对象

- 应用场景

  - 创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得
  - 如果系统要保存对象的状态，做备份使用

- 遗留问题:

  - 通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的

  - 浅拷贝实现 Cloneable，深拷贝是通过实现 Serializable 读取二进制流

  - 拓展

    - 浅拷贝

      ```
      如果原型对象的成员变量是基本数据类型（int、double、byte、boolean、char等），将复制一份给克隆对象；
      如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址
      通过覆盖Object类的clone()方法可以实现浅克隆
      ```

    - 深拷贝

      ```
      无论原型对象的成员变量是基本数据类型还是引用类型，都将复制一份给克隆对象，如果需要实现深克隆，可以通过序列化(Serializable)等方式来实现
      ```

    - 原型模式是内存二进制流的拷贝，比new对象性能高很多，使用的时候记得注意是选择浅拷贝还是深拷贝

  - 优点

    - 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，可以提高新实例的创建效率
    - 可辅助实现撤销操作，使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用恢复到历史状态

  - 缺点

    - 需要为每一个类配备一个克隆方法，对已有的类进行改造时，需要修改源代码，违背了“开闭原则”
    - 在实现深克隆时需要编写较为复杂的代码，且当对象之间存在多重的嵌套引用时，需要对每一层对象对应的类都必须支持深克隆

 ```java
 //ConcretePrototype
 import java.io.*;
 import java.util.ArrayList;
 import java.util.List;
 public class Person implements Cloneable,Serializable{
     private String name;
     private int age;
 
     public List<String> getList() {
         return list;
     }
 
     public void setList(List<String> list) {
         this.list = list;
     }
 
     List<String> list = new ArrayList<>();
 
 
     public int getAge() {
         return age;
     }
 
     public void setAge(int age) {
         this.age = age;
     }
 
     public String getName() {
         return name;
     }
 
     public void setName(String name) {
         this.name = name;
     }
 
     public Person deepClone(){
         try {
             //序列化
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(baos);
             oos.writeObject(this);
             //反序列化
             ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
             ObjectInputStream ois = new ObjectInputStream(bais);
             Person cooyObj = (Person) ois.readObject();
             return cooyObj;
         }catch (Exception e){
             e.printStackTrace();
             return null;
         }
     }
     @Override
     protected Person clone() throws CloneNotSupportedException {
         return (Person)super.clone();
     }
 }
 //Client
 public class Client {
     public static void main(String[] args) throws CloneNotSupportedException {
         Person person1 = new Person();
         person1.setName("小滴课堂老王");
         person1.setAge(50);
         person1.getList().add("aaaa");
         //深拷贝
         Person person2 = person1.clone();
         person2.setAge(20);
         person2.setName("Anna姐姐");
         person2.getList().add("bbbb");
 
         //浅拷贝
         Person person3 = person1.deepClone();
         person3.setAge(20);
         person3.setName("Anna姐姐");
         person3.getList().add("bbbb");
 
         System.out.println( person2 == person1);
         System.out.println("姓名："+person1.getName()+"， 年龄："+person1.getAge());
         System.out.println("姓名："+person2.getName()+"， 年龄："+person2.getAge());
     }
 }
 
 ```

##  创建型设计模式-建造者模式应用介绍

建造者模式（Builder Pattern）

- 使用多个简单的对象一步一步构建成一个复杂的对象，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 允许用户只通过指定复杂对象的类型和内容就可以构建它们，不需要知道内部的具体构建细节

电脑有低配、高配，组装需要CPU、内存、电源、硬盘、主板等

![image-20210510231613839](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510231616.png)

- 核心组成
  - Builder：抽象建造者，定义多个通用方法和构建方法
  - ConcreteBuilder：具体建造者，可以有多个
  - Director：指挥者，控制整个组合过程，将需求交给建造者，由建造者去创建对象
  - Product：产品角色

```java
//Builder
public interface Builder {
    void buildCpu();
    void buildMainBoard();
    void buildDisk();
    void buildPower();
    void buildMemory();
    Computer createComputer();
}
//HighComputerBuilder
public class HighComputerBuilder implements Builder{
    private Computer computer = new Computer();
    @Override
    public void buildCpu() {

        computer.setCpu("高配 cpu");
    }

    @Override
    public void buildMainBoard() {
        computer.setMainBoard("高配 主板");
    }

    @Override
    public void buildDisk() {
        computer.setDisk("高配 磁盘");
    }

    @Override
    public void buildPower() {
        computer.setPower("高配 电源");
    }

    @Override
    public void buildMemory() {
        computer.setMemory("高配 内存");
    }

    @Override
    public Computer createComputer() {
        return computer;
    }
}
//LowComputerBuilder
public class LowComputerBuilder implements Builder{
    private Computer computer = new Computer();
    @Override
    public void buildCpu() {
        computer.setCpu("低配 cpu");
    }

    @Override
    public void buildMainBoard() {
        computer.setMainBoard("低配 主板");
    }

    @Override
    public void buildDisk() {
        computer.setDisk("低配 磁盘");
    }

    @Override
    public void buildPower() {
        computer.setPower("低配电源");
    }

    @Override
    public void buildMemory() {
        computer.setMemory("低配 内存");
    }

    @Override
    public Computer createComputer() {
        return computer;
    }
}
//Computer
public class Computer {
    private String cpu;
    private String memory;
    private String mainBoard;
    private String disk;
    private String power;
    //一系列的set get方法

    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", memory='" + memory + '\'' +
                ", mainBoard='" + mainBoard + '\'' +
                ", disk='" + disk + '\'' +
                ", power='" + power + '\'' +
                '}';
    }
}
/*
 * 将产品使用和创建过程解耦，使用相同的创建过程创建不同的产品，控制产品生产过程
 * Director是全程指导组装过程，具体的细节还是builder去操作
 */
public class Director {

    public Computer create(Builder builder){
        builder.buildCpu();
        builder.buildMainBoard();
        builder.buildDisk();
        builder.buildPower();
        builder.buildMemory();
        return builder.createComputer();
    }
}
//建造者模式main类
Director director = new Director();
Computer lowComputer = director.create(new LowComputerBuilder());
System.out.println(lowComputer.toString());
Computer highComputer = director.create(new HighComputerBuilder());
System.out.println(highComputer.toString());
```

- 优点
  - 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦
  - 每一个具体建造者都相对独立，而与其他的具体建造者无关，更加精细地控制产品的创建过程
  - 增加新的具体建造者无须修改原有类库的代码，符合开闭原则
  - 建造者模式结合**链式编程**来使用，代码上更加美观
- 缺点
  - 建造者模式所创建的产品一般具有较多的共同点，如果产品差异大则不建议使用
- JDK里面的应用
  - tcp传输协议 protobuf 生成的api、java中的StringBuilder（不完全一样，思想一样）

- 建造者模式与抽象工厂模式的比较:
  - 建造者模式返回一个组装好的完整产品 ， 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族

# 结构型设计模式

## 接口之间的桥梁-适配器设计模式

- 适配器模式（Adapter Pattern）
  - 见名知意，是作为两个不兼容的接口之间的桥梁，属于结构型模式
  - 适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
  - 常见的几类适配器
    - 类的适配器模式
      - 想将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可
    - 对象的适配器模式
      - 想将一个对象转换成满足另一个新接口的对象时，可以创建一个适配器类，持有原类的一个实例，在适配器类的方法中，调用实例的方法就行
    - 接口的适配器模式
      - 不想实现一个接口中所有的方法时，可以创建一个Adapter，实现所有方法，在写别的类的时候，继承Adapter类即
    - 应用场景
      - 系统需要使用现有的类，而这些类的接口不符合系统的需要
      - JDK中InputStreamReader就是适配器
      - JDBC就是我们用的最多的适配器模式

```
JDBC给出一个客户端通用的抽象接口，每一个具体数据库厂商 如 SQL Server、Oracle、MySQL等，就会开发JDBC驱动，就是一个介于JDBC接口和数据库引擎接口之间的适配器软件
```

![image-20210510232523962](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510232526.png)

有些接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要实现部分接口就可以了

```java
public interface PayGateway {

    void unifiedorder();

    void refund();

    void query();

    void sendRedPack();
}
public class PayGatewayAdapter implements PayGateway {

    @Override
    public void unifiedorder() {

    }

    @Override
    public void refund() {

    }

    @Override
    public void query() {

    }

    @Override
    public void sendRedPack() {

    }
}
public class ProductVideoOrder extends PayGatewayAdapter {
    @Override
    public void unifiedorder() {
        System.out.println("ProductVideoOrder unifiedorder");
    }

    @Override
    public void refund() {
        System.out.println("ProductVideoOrder refund");
    }

}
public class ProductVipVideoOrder extends PayGatewayAdapter {
    @Override
    public void unifiedorder() {
        System.out.println("ProductVipVideoOrder unifiedorder");
    }

    @Override
    public void refund() {
        System.out.println("ProductVipVideoOrder refund");
    }

    @Override
    public void sendRedPack() {
        System.out.println("ProductVipVideoOrder sendRedPack");
    }

}

```

## 生产环境接口-需要兼容新的业务怎么办？

需求背景

```
小滴课堂里面有个电商支付项目，里面有个登录功能，已经线上运行了
客户端A 调用生产环境的登录接口B,且线上稳定运行了好几年。

某天，公司接到收购了别的公司的项目，需要把这套系统部署在起来，且收购的项目也有对应的客户端C，但是两个客户端和服务端的协议不一样

需求：收购的项目客户端C，需要做公司原来的项目用户数据打通，连接公司的服务端登录接口B，你能想到几个解决方案？

1、修改就项目B的登录接口，兼容C客户端协议（可能影响线上接口，不稳定）
2、新增全新的登录接口F,采用C客户端协议（和旧的业务逻辑会重复）
3、新增一个转换协议接口，客户端C调用旧的B接口之前，使用转换接口转换下协议（适配器模式，推荐这个方式）
```

![image-20210510232822435](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510232825.png)

总结

- 在使用一些旧系统或者是类库时，经常会出现接口不兼容的问题，适配器模式在解决这类问题具有优势
- 学习设计模式一定不要局限代码层面，要从软件系统整体去考虑,而不是为了使用设计模式，而去使用设计模式

- 优点
  - 可以让任何两个没有关联的类一起运行，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
  - 增加灵活度, 提高复用性，适配器类可以在多个系统使用,符合开闭原则
- 缺点
  - 整体类的调用链路增加，本来A可以直接调用C，使用适配器后 是A调用B，B再调用C

## 适配器设计模式-类的适配器

类的适配器模式

- 想将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可

![image-20210510233027577](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210510233030.png)

```java
public class OldModule {
    public void methodA(){
        System.out.println("OldModule methodA");
    }
}
public interface TargetModule {
    void methodA();
    void methodB();
    void methodC();
}
public class Adapter extends OldModule implements TargetModule{
    /**
     * 新的方法，和老的类方法不一样
     */
    @Override
    public void methodB() {
        System.out.println("Adapter methodB");
    }

    @Override
    public void methodC() {
        System.out.println("Adapter methodC");
    }
}
//main类
TargetModule targetModule = new Adapter();
targetModule.methodA();
targetModule.methodB();
```

## 设计模式疑惑指南-桥接设计模式

桥接设计模式

- 适配器模式类似，包括以后经常会遇到意思接近一样的设计模式，因为大神往往就是多个模式混用，且根据不同的场景进行搭配，桥接设计模式也是结构型模式
- 将抽象部分与实现部分分离，使它们都可以独立的变化
- 通俗来说，是通过组合来桥接其它的行为/维度
- 应用场景
  - 系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性
  - 不想使用继承导致系统类的个数急剧增加的系统
  - 有时候一个类，可能会拥有多个变化维度，比如啤酒，有不同的容量和品牌，可以使用继承组合的方式进行开发，假如维度很多，就容易出现类的膨胀，使用桥接模式就可以解决这个问题，且解耦

-  业务背景

```
我们需要构建一个手机类，我们知道手机有很多品牌，苹果、华为等，从另外一个颜色维度，又有多种颜色，红、黄、蓝等，

那如果描述这些类的话，传统方式就直接通过继承，就需要特别多的类，品牌2，颜色3，就是6个类了，如果后续再增加品牌就更多了，类数目将会激增，即所谓的类爆炸

使用桥接模式就可以解决这个问题，且灵活度大大提高
```

![image-20200928224430316](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200928224430316.png)

![image-20200928224458688](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200928224458688.png)

- 编码实战

```java
public interface Color {
    void useColor();
}
public abstract class Phone {

    protected Color color;
    public void setColor(Color color){
        this.color = color;
    }
    abstract public void run();
}
public class ApplePhone extends Phone{
    public ApplePhone(Color color){
        super.setColor(color);
    }
    @Override
    public void run() {
        color.useColor();
        System.out.println("苹果手机");
    }
}
public class HWPhone extends Phone{
    public HWPhone(Color color){
        super.setColor(color);
    }
    @Override
    public void run() {
        color.useColor();
        System.out.println("华为手机");
    }
}
public class BlueColor implements Color{
    @Override
    public void useColor() {
        System.out.println("蓝色");
    }
}
public class RedColor implements Color{
    @Override
    public void useColor() {
        System.out.println("红色");
    }
}
//桥接模式
HWPhone blueHwphone = new HWPhone(new BlueColor());
blueHwphone.run();

HWPhone redHwphone = new HWPhone(new RedColor());
redHwphone.run();

ApplePhone applePhone = new ApplePhone(new BlueColor());
applePhone.run();
```

- 优点
  - 抽象和实现的分离。
  - 优秀的扩展能力，符合开闭原则
- 缺点
  - 增加系统的理解与设计难度
  - 使用聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程，比如抽象类汽车，里面聚合了颜色类，有点像对象适配器
- 总结和对比
  - 按GOF的说法，桥接模式和适配器模式用于设计的不同阶段，
    - 桥接模式用于设计的前期，精细化的设计，让系统更加灵活
    - 适配器模式用于设计完成之后，发现类、接口之间无法一起工作，需要进行填坑
  - 适配器模式经常用在第三方API协同工作的场合，在功能集成需求越来越多的今天，这种模式的使用频度越来越高，包括有些同学听过 外观设计模式 ，这个也是某些场景和适配器模式一样

## 将对象组合成树形结构的模式-组合设计模式

- 组合设计模式
  - 又叫部分整体模式，将对象组合成树形结构以表示“部分-整体”的层次结构，可以更好的实现管理操作
  - 组合模式使得用户可以使用一致的方法操作单个对象和组合对象
  - 部分-整体对象的基本操作多数是一样的，但是应该还会有不一样的地方
  - 核心：组合模式可以使用一棵树来表示
- 应用场景
  - 银行总行，总行有前台、后勤、网络部门等，辖区下还有地方分行，也有前台、后勤、网络部门，最小的分行就没有子分行了
  - 公司也是，总公司下有子公司，每个公司大部分的部门都类似
  - 文件夹和文件，都有增加、删除等api，也有层级管理关系
  - 当想表达对象的部分-整体的层次结构
  - 当我们的要处理的对象可以生成一颗树形结构，我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子
- 角色
  - 组合部件（Component）：它是一个抽象接口，表示树根，例子：总行
  - 合成部件（Composite）：和组合部件类似，也有自己的子节点，例子：总行下的分行
  - 叶子（Leaf）：在组合中表示子节点对象，注意是没有子节点，例子：最小地方的分行

- 编码实战

```java
public abstract class Root {
    private String name;

    public Root(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    public abstract void addFile(Root root);

    public abstract void removeFile(Root root);

    public abstract void display(int depth);

}
public class File extends Root{
    public File(String name) {
        super(name);
    }

    @Override
    public void addFile(Root root) {

    }

    @Override
    public void removeFile(Root root) {

    }

    @Override
    public void display(int depth) {
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<depth;i++){
            sb.append("-");
        }
        //打印横线和当前文件名
        System.out.println(sb.toString()+this.getName());
    }
}
public class Folder extends Root{

    List<Root> folders = new ArrayList<>();

    public List<Root> getFolders(){
        return folders;
    }
    public void setFolders(List<Root> folders){
        this.folders = folders;
    }

    public Folder(String name) {
        super(name);
    }

    @Override
    public void addFile(Root root) {
        folders.add(root);
    }

    @Override
    public void removeFile(Root root) {
        folders.remove(root);
    }

    @Override
    public void display(int depth) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < depth; i++){
            sb.append("-");
        }
        System.out.println(sb.toString()+this.getName());
        for(Root r : folders){
            r.display(depth+2);
        }
    }
}

```

- 缺点
  - 客户端需要花更多时间理清类之间的层次关系
- 优点
  - 客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题
  - 方便创建出复杂的层次结构

## 装饰器设计模式介绍

装饰器设计模式（Decorator Pattern）

- 也叫包装设计模式，属于结构型模式，它是作为现有的类的一个包装，允许向一个现有的对象添加新的功能，同时又不改变其结构
- 给对象增加功能，一般两种方式 继承或关联组合，将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为来增强功能，这个就是装饰器模式，比继承模式更加灵活

- 以动态、透明的方式给单个对象添加职责，但又能不改变其结构
- JDK源码里面应用的最多的就是IO流，大量使用装饰设计模式

![image-20200929170148219](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200929170148219.png)

- 角色（装饰者和被装饰者有相同的超类(Component)）
  - 抽象组件（Component）
    - 定义装饰方法的规范，最初的自行车，仅仅定义了自行车的API；
  - 被装饰者（ConcreteComponent）
    - Component的具体实现，也就是我们要装饰的具体对象
    - 实现了核心角色的具体自行车
  - 装饰者组件（Decorator）
    - 定义具体装饰者的行为规范, 和Component角色有相同的接口，持有组件(Component)对象的实例引用
    - 自行车组件 都有 名称和价格 
  - 具体装饰物（ConcreteDecorator）
    - 负责给构件对象装饰附加的功能
    - 比如 喇叭，防爆胎

```java
public interface Bike {
    String getDescription();

    int getPrice();
}
public class BigBike implements Bike {

    private String description = "大号自行车";
    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public int getPrice() {
        return 200;
    }
}
public class SmallBike implements Bike {

    private String description = "小号自行车";
    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public int getPrice() {
        return 100;
    }
}
public class BikeDecorator implements Bike{

    private String description = "我只是装饰器，我啥也不表示，子类帮我传递";

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public int getPrice() {
        return 0;
    }
}
public class RSCBikeDecorator extends BikeDecorator{

    private String description = "增加一个防爆胎";

    /**
     * 把接口下沉到具体装饰物里面
     */
    private Bike bike;

    public RSCBikeDecorator(Bike bike){
        this.bike = bike;
    }
    @Override
    public String getDescription() {
        return bike.getDescription() + ","+ description;
    }

    /**
     * 100是防爆胎的价格
     * @return
     */
    @Override
    public int getPrice() {
        return bike.getPrice()+100;
    }
}
public class SuonaBikeDecorator extends BikeDecorator{

    private String description = "增加一个喇叭";

    /**
     * 把接口下沉到具体装饰物里面
     */
    private Bike bike;

    public SuonaBikeDecorator(Bike bike){
        this.bike = bike;
    }
    @Override
    public String getDescription() {
        return bike.getDescription() + ","+ description;
    }

    /**
     * 50是喇叭的价格
     * @return
     */
    @Override
    public int getPrice() {
        return bike.getPrice()+50;
    }
}

```

- 优点
  - 装饰模式与继承关系的目的都是要扩展对象的功能，但装饰模式可以提供比继承更多的灵活性。
  - 使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，原有代码无须改变，符合“开闭原则”

- 缺点

  - 装饰模式增加了许多子类，如果过度使用会使程序变得很复杂 (多层包装)
  - 增加系统的复杂度，加大学习与理解的难度

- 装饰器模式和桥接模式对比

  - 相同点都是通过封装其他对象达到设计的目的，和对象适配器也类似，有时也叫半装饰设计模式

  - 没有装饰者和被装饰者的主次区别，桥接和被桥接者是平等的，桥接可以互换，不用继承自同一个父类

    比如例子里面的，可以是Phone持有Color，也可以是Color持有Phone

    ![image-20200928224524790](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200928224524790.png)

  - 桥接模式不用使用同一个接口；装饰模式用同一个接口装饰，接口在父类中定义

##  JDK源码里面的Stream IO流-装饰器设计模式应用

- 抽象组件（Component）：InputStream
  - 定义装饰方法的规范
- 被装饰者（ConcreteComponent) : FileInputStream 、ByteArrayInputStream
  - Component的具体实现，也就是我们要装饰的具体对象
- 装饰者组件（Decorator）：FilterInputStream
  - 定义具体装饰者的行为规范, 和Component角色有相同的接口，持有组件(Component)对象的实例引用
  - 自行车组件 都有 名称和价格

- 具体装饰物（ConcreteDecorator）:BufferedInputStream、DataInputStream
  - 负责给构件对象装饰附加的功能
  - 比如 喇叭，防爆胎

![image-20200929172105246](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200929172105246.png)

```
//添加了Buffer缓冲功能
InputStream inputStream = new BufferedInputStream(new FileInputStream(""));
```

## 代理设计模式

代理设计模式（Proxy Pattern）

- 为其他对象提供一种代理以控制对这个对象的访问，属于结构型模式。
- 客户端并不直接调用实际的对象，而是通过调用代理，来间接的调用实际的对象

- 应用场景

  - 各大数码专营店，代理厂商进行销售对应的产品，代理商持有真正的授权代理书

  - 客户端不想直接访问实际的对象，或者访问实际的对象存在困难，通过一个代理对象来完成间接的访问

  - 想在访问一个类时做一些控制，或者增强功能

    ![timg](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/timg1.png)

- 角色

  - Subject: 抽象接口,真实对象和代理对象都要实现的一个抽象接口，好比销售数码产品
  - Proxy： 包含了对真实对象的引用,从而可以随意的操作真实对象的方法，好比 代理加盟店
  - RealProject ：真实对象，好比厂商销售数码产品

![image-20201002093501076](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201002093501076.png)

- 业务需求

```
小滴课堂-老王，想开个数码小卖部，为以后退休生活做准备，代理各大厂商的手机和电脑，用代理设计模式帮他实现下

Subject 卖手机

RealProject 苹果、华为厂商，核心是卖手机，但是选址不熟悉

Proxy 老王数码专卖店：代理卖手机，附加选地址，增加广告等
```

- 编码实战

```java
public interface DigitalSell {

    void sell();
}
public class DigitalSellReal implements DigitalSell{
    @Override
    public void sell() {
        System.out.println("销售华为手机");
    }
}
public class DigitalSellProxy implements DigitalSell{

    private DigitalSell realObj = new DigitalSellReal();

    @Override
    public void sell() {
        makeAddress();
        realObj.sell();
        makeAD();
    }
    private void makeAddress(){
        System.out.println("一个人流量很高的地址");
    }
    private void makeAD(){
        System.out.println("投放广告");
    }
}
```

- 优点
  - 可以在访问一个类时做一些控制，或增加功能
  - 操作代理类无须修改原本的源代码，符合开闭原则，系统具有较好的灵活性和可扩展性
- 缺点
  - 增加系统复杂性和调用链路

- 有静态代理和动态代理两种
  - 动态代理也有多种方式，cglib、jdk
- 和装饰器模式的区别：
  - 代理模式主要是两个功能
    - 保护目标对象
    - 增强目标对象，和装饰模式类似

## 外观设计模式

外观设计模式 Facade Pattern

- 门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口
- 定义了一个高层接口，这个接口使得这系统更加容易使用

- 应用场景
  - 在外人看来，小滴课堂-老王是负责消息推送这个工作，看起来很轻松，但他们不知道里面有多复杂，老王加班多久才输出一个统一的接口，只要轻松操作就可以完成复杂的事情
  - 开发里面MVC三层架构，在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间使用interface接口进行交互，不用担心内部逻辑，降低耦合性
  - 各种第三方SDK大多会使用外观模式，通过一个外观类，也就是整个系统的接口只有一个统一的高层接口，这对用户屏蔽很多实现细节，外观模式经常用在封装API的常用手段
  - 对于复杂难以维护的老系统进行拓展，可以使用外观设计模式
  - 需要对一个复杂的模块或子系统提供一个外界访问的接口，外界对子系统的访问只要黑盒操作
- 角色
  - 外观角色(Facade)：客户端可以调用这个角色的方法，这个外观方法知道多个子系统的功能和实际调用
  - 子系统角色(SubSystem)：每个子系统都可以被客户端直接调用，子系统并不知道门面的存在

![image-20201002113738990](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201002113738990.png)

## 外观设计模式在多渠道消息推送里面的应用

- 业务需求

```
在外人看来，小滴课堂-老王是负责消息推送这个工作，看起来很轻松，但他们不知道里面有多复杂

需要对接微信消息、邮件消息、钉钉消息等，老王加班长期加班没有女友，才输出一个统一的接口，只要轻松操作就可以完成复杂的事情

用外观设计模式帮老王完成这个需求
```

- 编码实战

```java
public interface ImessageManager {
    void pushMessage();
}
public class DingDingMessageManager implements ImessageManager{
    @Override
    public void pushMessage() {
        System.out.println("推送钉钉消息");
    }
}
public class MailMessageManager implements ImessageManager {

    @Override
    public void pushMessage() {
        System.out.println("推送邮件消息");
    }
}
public class SmsMessageManager implements ImessageManager{
    @Override
    public void pushMessage() {
        System.out.println("推送短信消息");
    }
}
public class WechatMessageManager implements ImessageManager{

    @Override
    public void pushMessage() {
        System.out.println("推送微信消息");
    }
}
public class MessageFacade implements ImessageManager{
    private ImessageManager wechatMessageManager = new WechatMessageManager();
    private ImessageManager smsMessageManager = new SmsMessageManager();
    private ImessageManager mailMessageManager = new MailMessageManager();
    private ImessageManager dingDingMessageManager = new DingDingMessageManager();

    @Override
    public void pushMessage() {
        wechatMessageManager.pushMessage();
        smsMessageManager.pushMessage();
        mailMessageManager.pushMessage();
        dingDingMessageManager.pushMessage();
    }
}
//外观模式
ImessageManager imessageManager = new MessageFacade();
imessageManager.pushMessage();
```

- 优点
  - 减少了系统的相互依赖，提高了灵活性
  - 符合依赖倒转原则
    - 针对接口编程，依赖于抽象而不依赖于具体
  - 符合迪米特法则
    - 最少知道原则，一个实体应当尽量少地与其他实体之间发生相互作用
- 缺点
  - 增加了系统的类和链路
  - 不是很符合开闭原则，如果增加了新的逻辑，需要修改facade外观类

## Flyweight Pattern享元设计模式

- 享元设计模式(Flyweight Pattern)
  - 属于结构型模式，主要用于减少创建对象的数量，以减少内存占用和提高性能， 它提供了减少对象数量从而改善应用所需的对象结构的方式。
  - 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象

- 应用场景
  - JAVA 中的 String，如果字符串常量池里有则返回，如果没有则创建一个字符串保存在字符串常量池里面
  - 数据库连接池、线程池等
  - 如果系统有大量相似对象，或者需要用需要缓冲池的时候可以使用享元设计模式，也就是大家说的池化技术
  - 如果发现某个对象的生成了大量细粒度的实例，并且这些实例除了几个参数外基本是相同的，如果把那些共享参数移到类外面，在方法调用时将他们传递进来，就可以通过共享对象，减少实例的个数

- 内部状态
  - 不会随环境的改变而有所不同，是可以共享的
- 外部状态
  - 不可以共享的，它随环境的改变而改变的，因此外部状态是由客户端来保持（因为环境的变化一般是由客户端引起的）

- 角色
  - 抽象享元角色：为具体享元角色规定了必须实现的方法，而外部状态就是以参数的形式通过此方法传入
  - 具体享元角色：实现抽象角色规定的方法。如果存在内部状态，就负责为内部状态提供存储空间。
  - 享元工厂角色：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键
  - 客户端角色：维护对所有享元对象的引用，而且还需要存储对应的外部状态

![image-20201004120620154](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201004120620154.png)

- 案例实战

```
小滴课堂-老王为了增加收入，开始接了外包项目，开发了一个AI网站模板，可以根据不同的客户需求自动生成不同类型的网站
电商类、企业产品展示、信息流等。

在部署的时候就麻烦了，是不是每个机器都用租用云服务器，购买独立域名呢

这些网站结构相似度很高，而且都不是高访问量网站，可以先公用服务器资源，减少服务器资源成本，类似虚拟机或者Docker
```

- 编码实战

```java
public abstract class CloudWebSite {
    public abstract void run(Company company);
}
public class Company {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    public Company(){

    }
    public Company(String name) {
        this.name = name;
    }
}
public class ConcreteWebSite extends CloudWebSite{

    private String category;
    public ConcreteWebSite(String category){
        this.category = category;
    }
    @Override
    public void run(Company company) {
        System.out.println("网站分类"+category+",公司"+company.getName());
    }
}
public class WebSiteFactory {

    /**
     * 复用站点
     */
    private Map<String,ConcreteWebSite> map = new HashMap<>();
    public CloudWebSite getWebSiteByCategory(String category){
        if(map.containsKey(category)){
            return map.get(category);
        }else {
            ConcreteWebSite site = new ConcreteWebSite(category);
            map.put(category,site);
            return site;
        }
    }

    /**
     * 获取分类个数
     * @return
     */
    public int getWebSiteSize(){
        return map.size();
    }
}
//享元设计模式
WebSiteFactory factory = new WebSiteFactory();

CloudWebSite companysite1 = factory.getWebSiteByCategory("企业官网");
companysite1.run(new Company("小滴科技"));

CloudWebSite companysite2 = factory.getWebSiteByCategory("企业官网");
companysite2.run(new Company("旭瑶课堂"));

CloudWebSite byteDance = factory.getWebSiteByCategory("信息流");
byteDance.run(new Company("字节跳动"));
System.out.println("网站分类总数："+factory.getWebSiteSize());
```

- 优点
  - 大大减少了对象的创建，降低了程序内存的占用，提高效率
- 缺点
  - 提高了系统的复杂度，需要分离出内部状态和外部状态

- 注意划分内部状态和外部状态，否则可能会引起线程安全问题，必须有一个工厂类加以控制

- 享元设计模式和原型、单例模式的区别
  - 原型设计模式是指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。
  - 单例设计模式保证一个类仅有一个实例

# 关注对象之间的通信-行为型模式应用

## 玩转策略模式和应用场景

- 策略模式(Strategy Pattern)
  - 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
  - 淘宝天猫双十一，正在搞活动有打折的、有满减的、有返利的等等，这些算法只是一种策略，并且是随时都可能互相替换的, 我们就可以定义一组算法，将每个算法都封装起来，并且使它们之间可以互换
- 应用场景
  - 老王计划外出旅游，选择骑自行车、坐汽车、飞机等，每一种旅行方式都是一个策略
  - Java AWT中的LayoutManager，即布局管理器
  - 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么可以使用策略模式
  - 不希望暴露复杂的、与算法有关的数据结构，那么可以使用策略模式来封装算法
- 角色
  - Context上下文：屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化
  - Strategy策略角色：抽象策略角色，是对策略、算法家族的抽象，定义每个策略或算法必须具有的方法和属性
  - ConcreteStrategy具体策略角色：用于实现抽象策略中的操作，即实现具体的算法

![image-20201007204507604](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201007204507604.png)

- 业务需求

```
老王面试进了大厂，是电商项目的营销活动组，负责多个营销活动，有折扣、优惠券抵扣、满减等，项目上线后，产品经理找茬，经常新增营销活动，导致代码改动多，加班严重搞的老王很恼火。

他发现这些都是活动策略，商品的价格是根据不同的活动策略进行计算的，因此用策略设计模式进行了优化，后续新增策略后只要简单配置就行了，不用大动干戈
```

- 编码实战

```java
public class ProductOrder {

    private double oldPrice;

    private int userId;

    private int productId;

    public double getOldPrice() {
        return oldPrice;
    }
    public ProductOrder(double oldPrice, int userId, int productId){
        this.oldPrice = oldPrice;

        this.userId = userId;

        this.productId = productId;
    }

    public void setOldPrice(double oldPrice) {
        this.oldPrice = oldPrice;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public int getProductId() {
        return productId;
    }

    public void setProductId(int productId) {
        this.productId = productId;
    }
}
public abstract class Strategy {

    /**
     * 根据简单订单对象，计算商品折扣后的价格
     * @param productOrder
     * @return
     */
    public abstract double computePrice(ProductOrder productOrder);

}
public class DiscountActivity extends Strategy{

    /**
     * 具体的折扣
     */
    private double rate;

    public DiscountActivity(double rate){
        this.rate = rate;
    }

    @Override
    public double computePrice(ProductOrder productOrder) {
        //一系列复杂的计算
        return productOrder.getOldPrice() * rate;
    }
}
public class NormalActivity extends Strategy{

    @Override
    public double computePrice(ProductOrder productOrder) {
        return productOrder.getOldPrice();
    }
}
public class VoucherActivity extends Strategy{

    /**
     * 传入优惠劵
     */
    private double voucher;

    public VoucherActivity(double voucher){
        this.voucher = voucher;
    }
    @Override
    public double computePrice(ProductOrder productOrder) {

        if(productOrder.getOldPrice() > voucher){
            return  productOrder.getOldPrice() - voucher;
        }else {
            return 0;
        }
    }
}
public class PromotionContext {

    private Strategy strategy;

    public PromotionContext(Strategy strategy){
        this.strategy = strategy;
    }

    /**
     * 根据策略计算最终的价格
     * @param productOrder
     * @return
     */
    public double executeStrategy(ProductOrder productOrder){
        return strategy.computePrice(productOrder);
    }
}
//main类
ProductOrder productOrder = new ProductOrder(800, 1, 33);

PromotionContext context;

double finalPrice;

//不同策略算出不同的活动的价格
context = new PromotionContext(new NormalActivity());
finalPrice =  context.executeStrategy(productOrder);
System.out.println("NormalActivity = "+finalPrice);

//折扣策略
context = new PromotionContext(new DiscountActivity(0.8));
finalPrice =  context.executeStrategy(productOrder);
System.out.println("DiscountActivity = "+finalPrice);

//优惠券抵扣
context = new PromotionContext(new VoucherActivity(100));
finalPrice =  context.executeStrategy(productOrder);
System.out.println("VoucherActivity = "+finalPrice);	
```

## 模板方法设计模式介绍

模板方法模式Template Method

- 定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤，属于行为型模式

- 应用场景
  - javaweb里面的Servlet，HttpService类提供了一个service()方法，
  - 有多个子类共有逻辑相同的方法，可以考虑作为模板方法
  - 设计一个系统时知道了算法所需的关键步骤，且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，可以延迟到子类进行完成
- 角色
  - 抽象模板(Abstract Template): 定义一个模板方法，这个模板方法一般是一个具体方法，给出一个顶级算法骨架，而逻辑骨架的组成步骤在相应的抽象操作中，推迟到子类实现
    - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法
    - 基本方法：是整个算法中的一个步骤，包括抽象方法和具体方法
      - 抽象方法：在抽象类中申明，由具体子类实现。
      - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它
  - 具体模板(Concrete Template):实现父类所定义的一个或多个抽象方法，它们是一个顶级算法逻辑的组成步骤

![image-20201009162228693](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201009162228693.png)

- 需求背景

```
小滴课堂-老王成功晋升为管理者，但是团队来了很多新兵，由于团队水平参差不齐，经常有新项目进来，但整体流程很不规范。
 
 一个项目的生命周期：需求评审-设计-开发-测试-上线-运维。整个周期里面，需求评审-设计是固定的操作，而其他步骤则流程耗时等是根据项目来定的。

因此老王梳理了一个模板，来规范化项目，他只管核心步骤和项目里程碑产出的结果，具体的工时安排和开发就让团队成员去操作
```

- 编码实战

```java
public abstract class AbstractProjectManager {
    /**
     * 定义模板方法，声明final，防止子类覆盖他，更改顺序，流程一样复用
     */
    public final void processProject(){
        review();
        design();
        coding();
        test();
        online();
    }

    /**
     * 各个项目都需要评审
     */
    public void review(){
        System.out.println("项目需求评审");
    }

    /**
     * 各个项目都需要设计
     */
    public void design(){
        System.out.println("UI UE进行设计");
    }

    /**
     * 抽象方法，由具体子类进行实现，编码耗时不一样
     */
    public abstract void coding();

    /**
     * 抽象方法，由具体子类进行实现，编码耗时不一样，自动化测试，安全测试，压力测试
     */
    public abstract void test();

    /**
     * 抽象方法，由具体子类进行实现，上线有全量发布，灰度发布，停机发布
     */
    public abstract void online();
}
public class PayServiceProjectManager extends AbstractProjectManager{

    @Override
    public void coding() {
        System.out.println("开发耗时30天");
    }

    @Override
    public void test() {
        System.out.println("功能测试，安全测试，压力测试");

    }

    @Override
    public void online() {
        System.out.println("全量上线");
    }
}
public class UserServiceProjectManager extends AbstractProjectManager{
    @Override
    public void coding() {
        System.out.println("开发耗时10天");
    }

    @Override
    public void test() {
        System.out.println("功能测试，压力测试，手工测试");

    }

    @Override
    public void online() {
        System.out.println("灰度发布，全量上线");
    }
}
//main类	
AbstractProjectManager projectManager;
projectManager = new PayServiceProjectManager();
projectManager.processProject();
projectManager = new UserServiceProjectManager();
projectManager.processProject();
```

- 优点
  - 扩展性好，对不变的代码进行封装，对可变的进行扩展，符合 开闭原则
- 提高代码复用性 将相同部分的代码放在抽象的父类中，将不同的代码放入不同的子类中
  - 通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制
- 缺点
  - 每一个不同的实现都需要一个子类来实现，导致类的个数增加，会使系统变得复杂
- 模板方法模式和建造者模式区别

```
两者很大的交集，建造者模式比模板方法模式多了一个指挥类，该类体现的是模板方法模式中抽象类的固定算法的功能，是一个创建对象的固定算法
```

## Observer观察者设计模式

- 观察者模式
  - 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新，也叫做发布订阅模式**Publish/Subscribe**，属于行为型模式

- 应用场景
  - 消息通知里面：邮件通知、广播通知、微信朋友圈、微博私信等，就是监听观察事件
  - 当一个对象的改变需要同时改变其它对象，且它不知道具体有多少对象有待改变的时候，考虑使用观察者模式

- 角色

  - Subject主题：持有多个观察者对象的引用，抽象主题提供了一个接口可以增加和删除观察者对象；有一个观察者数组，并实现增、删及通知操作

  - Observer抽象观察者：为具体观察者定义一个接口，在得到主题的通知时更新自己

  - ConcreteSubject具体主题：将有关状态存入具体观察者对象，在具体主题内部状态改变时，给所有登记过的观察者发出通知

  - ConcreteObserver具体观察者：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态保持一致

![image-20201009215732910](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201009215732910.png)

- 业务需求

```
小滴课堂-老王，技术比较厉害，因此上班不想那么辛苦，领导又在周围，所以选了个好位置，方便监听老板的到来，
当领导即将出现时老王可以立马观察到，赶紧工作。

用观察者模式帮助老王实现这个需求
```

- 编码实战

```java
public class Subject {
    private List<Observer> observerList = new ArrayList<>();
    /**
     * 新增观察者
     * @param observer
     */
    public void addObserver(Observer observer){
        this.observerList.add(observer);
    }
    /**
     *删除观察者
     * @param observer
     */
    public void deleteObserver(Observer observer){
        this.observerList.remove(observer);
    }
    public void notifyAllObserver(){
        for(Observer observer:this.observerList){
            observer.update();
        }
    }
}
public interface Observer {
    /**
     * 观察到消息后进行的操作，就是响应
     */
    void update();
}
/**
 * @Description 消息发布者
 **/
public class BossConcreteSubject extends Subject {
    public void doSomething(){
        System.out.println("老板完成自己的工作");
        //还有其他操作
        System.out.println("视察公司工作情况");
        super.notifyAllObserver();
    }
}
/**
 * @Description 消息的消费者
 **/
public class LWConcreteObserver implements Observer {
    @Override
    public void update() {
        System.out.println("老王发现领导到来，暂停在线摸鱼，回归工作");
    }
}
public class AnnaConcreteObserver implements Observer {

    @Override
    public void update() {
        System.out.println("Anna小姐姐发现领导到来，暂停在线摸鱼，回归工作");
    }
}

//使用
public static void main(String[] args) {
        //创建一个主题，老板
        BossConcreteSubject subject = new BossConcreteSubject();
        //创建观察者，就是摸鱼的同事
        Observer lwObserver = new LWConcreteObserver();
        //创建观察者，就是摸鱼的同事
        Observer annaObserver = new AnnaConcreteObserver();
        //建立对应的关系，老板这个主题被同事进行观察
        subject.addObserver(lwObserver);
        subject.addObserver(annaObserver);
        //主题开始活动，里面会通知观察者（相当于发布消息）
        subject.doSomething();
    }
```

- 优点
  - 降低了目标与观察者之间的耦合关系，目标与观察者之间建立了一套触发机制
  - 观察者和被观察者是抽象耦合的
- 缺点
  - 观察者和观察目标之间有循环依赖的话，会触发它们之间进行循环调用，可能导致系统崩溃
  - 一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间

## 责任链设计模式

- 责任链设计模式(Chain of Responsibility Pattern)
  - 客户端发出一个请求，链上的对象都有机会来处理这一请求，而客户端不需要知道谁是具体的处理对象
  - 让多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系，将这个对象连成一条调用链，并沿着这条链传递该请求，直到有一个对象处理它才终止
  - 有两个核心行为：一是处理请求，二是将请求传递到下一节点

- 应用场景
  - Apache Tomcat 对 Encoding 编码处理的处理，SpringBoot里面的拦截器、过滤器链
  - 在请求处理者不明确的情况下向多个对象中的一个提交请求
  - 如果有多个对象可以处理同一个请求，但是具体由哪个对象处理是由运行时刻动态决定的，这种对象就可以使用职责链模式

- 角色
  - Handler抽象处理者：定义了一个处理请求的接口
  - ConcreteHandler具体处理者： 处理所负责的请求，可访问它的后续节点，如果可处理该请求就处理，否则就将该请求转发给它的后续节点

![image-20201011170107379](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201011170107379.png)

- 业务需求

```
风控规则，就是对于每个场景，定义一些规则，来进行相应的控制，比如银行借款、支付宝提现、大额转账等 会触发不同的策略。

像互联网金融行业的话，除了公司内部政策，所处的外部环境经常发生变化，比如国家经常会出政策，这些都经常需要调整相应的风控参数和风控级别。

例子：支付宝转账，根据转账额度不同，会触发的风控级别不一样，1000元以下直接转，1千到1万需要手机号验证码，1万到以上需要刷脸验证。
```

![image-20201011170011367](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201011170011367.png) 

- 编码实战

```java
public class Request {
    /**
     * 类别
     */
    private String requestType;
    /**
     * 金额
     */
    private int money;
  
  //set get方法省略
}
public enum RequestType {
    /**
     * 转账
     */
    TRANSFER,
    /**
     * 提现
     */
    CASH_OUT;
}
/**
 * @Description 风控级别抽象类
 **/
public abstract class RiskControlManager {
    protected  String name;
    /**
     * 更严格的风控策略
     */
    protected RiskControlManager superior;
    public RiskControlManager(String name){
        this.name = name;
    }
    /**
     * 设置更严格的风控策略
     * @param superior
     */
    public void setSuperior(RiskControlManager superior){
        this.superior = superior;
    }
    /**
     * 处理请求
     * @param request
     */
    public abstract void handlerRequest(Request request);
}
/**
 * 小滴课堂,愿景：让技术不再难学  https://xdclass.net
 *
 * @Description 风控级别抽象类
 * @Author 二当家小D
 * @Remark 有问题直接联系我，源码-笔记-技术交流群 微信 xdclass6
 * @Version 1.0
 **/
public class FirstRiskControlManager extends RiskControlManager {
    public FirstRiskControlManager(String name) {
        super(name);
    }
    /**
     *  1000元以内可以直接处理
     * @param request
     */
    @Override
    public void handlerRequest(Request request) {
        if(RequestType.valueOf(request.getRequestType())!=null && request.getMoney()<=1000){
            System.out.println("普通操作，输入支付密码即可");
            System.out.println(name+":"+request.getRequestType() + ", 金额:"+request.getMoney() +" 处理完成");
        }else {
            //下个节点进行处理
            if(superior!=null){
                superior.handlerRequest(request);
            }
        }
    }
}
public class SecondRiskControlManager extends RiskControlManager {
    public SecondRiskControlManager(String name) {
        super(name);
    }
    /**
     * 处理 1千到1万之间
     * @param request
     */
    @Override
    public void handlerRequest(Request request) {
        if(RequestType.valueOf(request.getRequestType())!=null && request.getMoney()>1000 && request.getMoney()<10000){
            System.out.println("稍大额操作，输入支付密码+短信验证码即可");
            System.out.println(name+":"+request.getRequestType() + ", 金额:"+request.getMoney() +" 处理完成");
        }else {
            //下个节点进行处理
            if(superior!=null){
                superior.handlerRequest(request);
            }
        }
    }
}
public class ThirdRiskControlManager extends RiskControlManager {
    public ThirdRiskControlManager(String name) {
        super(name);
    }
    @Override
    public void handlerRequest(Request request) {
        if(RequestType.valueOf(request.getRequestType())!=null && request.getMoney()>10000){
            System.out.println("大额操作，输入支付密码+验证码+人脸识别 ");
            System.out.println(name+":"+request.getRequestType() + ", 金额:"+request.getMoney() +" 处理完成");
        }else {
            //下个节点进行处理
            if(superior!=null){
                superior.handlerRequest(request);
            }
        }
    }
}
//使用
public static void main(String[] args) {
        RiskControlManager firstControlManager = new FirstRiskControlManager("初级风控");
        RiskControlManager secondControlManager = new SecondRiskControlManager("中级风控");
        RiskControlManager thirdControlManager = new ThirdRiskControlManager("高级风控");
        //形成调用链
        firstControlManager.setSuperior(secondControlManager);
        secondControlManager.setSuperior(thirdControlManager);
        //使用
        Request request1 = new Request();
        request1.setRequestType(RequestType.CASH_OUT.name());
        request1.setMoney(20000);
        firstControlManager.handlerRequest(request1);
    }
```

- 优点
  - 客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者 降低了耦合度
  - 通过改变链内的调动它们的次序，允许动态地新增或者删除处理类，比较很方便维护
  - 增强了系统的可扩展性，可以根据需要增加新的请求处理类，满足开闭原则
  - 每个类只需要处理自己该处理的工作，明确各类的责任范围，满足单一职责原则

- 缺点
  - 处理都分散到了单独的职责对象中，每个对象功能单一，要把整个流程处理完，需要很多的职责对象，会产生大量的细粒度职责对象
  - 不能保证请求一定被接收；
  - 如果链路比较长，系统性能将受到一定影响，而且在进行代码调试时不太方便

- 日志处理级别
  - dubug->info->warning->error

## Command Pattern命令设计模式

- 命令设计模式（Command Pattern）
  - 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的对象，并把该命令传给相应的对象 执行命令，属于行为型模式
  - 命令模式是一种特殊的策略模式，体现的是多个策略执行的问题，而不是选择的问题

- 应用场景
  - 只要是你认为是命令的地方，就可以采用命令模式
  - 日常每个界面、按钮、键盘 事件操作都是 命令设计模式

- 角色

  - 抽象命令(Command)：需要执行的所有命令都在这里声明
  - 具体命令(ConcreteCommand)：定义一个接收者和行为之间的弱耦合，实现execute()方法，负责调用接收者的相应操作，execute()方法通常叫做执行方法。

  - 接受者(Receiver)：负责具体实施和执行一个请求，干活的角色，命令传递到这里是应该被执行的，实施和执行请求的方法叫做行动方法

  - 请求者(Invoker)：负责调用命令对象执行请求，相关的方法叫做行动方法
  - 客户端(Client)：创建一个具体命令(ConcreteCommand)对象并确定其接收者。

![image-20201011220112296](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201011220112296.png)

- 业务需求

```
小滴课堂老王-搬新家了，他想实现智能家居，开发一个app，可以控制家里的家电，比如控制空调的开关、加热、制冷 等功能

利用命令设计模式，帮老王完成这个需求，注意：动作请求者就是手机app, 动作的执行者是家电的不同功能
```

- 编码实战

```java
public interface Command {
    /**
     * 执行动作
     */
    void execute();
}
public class ConditionReceiver {
    public void on(){
        System.out.println("空调开启了");
    }

    public void off(){
        System.out.println("空调关闭了");
    }

    public void cool(){
        System.out.println("空调开始制冷");
    }

    public void warm(){
        System.out.println("空调开始制暖");
    }
}
public class CoolCommand implements Command{
    /**
     * 对哪个receiver 进行命令处理
     */
    private ConditionReceiver receiver;
    public CoolCommand(ConditionReceiver receiver){
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        System.out.println("CoolCommand -> execute");
        receiver.cool();
    }
}
public class OffCommand implements Command{
    /**
     * 对哪个receiver 进行命令处理
     */
    private ConditionReceiver receiver;

    public OffCommand(ConditionReceiver receiver){
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        System.out.println("OffCommand -> execute");
        receiver.off();
    }
}
public class OnCommand implements Command{
    /**
     * 对哪个receiver 进行命令处理
     */
    private ConditionReceiver receiver;
    public OnCommand(ConditionReceiver receiver){
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        System.out.println("OnCommand -> execute");
        receiver.on();
    }
}
public class WarmCommand implements Command{
    /**
     * 对哪个receiver 进行命令处理
     */
    private ConditionReceiver receiver;

    public WarmCommand(ConditionReceiver receiver){
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        System.out.println("WarmCommand -> execute");
        receiver.cool();
    }
}
/**
 * 小滴课堂,愿景：让技术不再难学  https://xdclass.net
 *
 * @Description 请求者
 * @Author 二当家小D
 * @Remark 有问题直接联系我，源码-笔记-技术交流群 微信 xdclass6
 * @Version 1.0
 **/
public class AppInvoker {
    private Command onCommand;
    private Command offCommand;
    private Command coolCommand;
    private Command warmCommand;
    public void setOnCommand(Command onCommand) {
        this.onCommand = onCommand;
    }
    public void setOffCommand(Command offCommand) {
        this.offCommand = offCommand;
    }
    public void setCoolCommand(Command coolCommand) {
        this.coolCommand = coolCommand;
    }
    public void setWarmCommand(Command warmCommand) {
        this.warmCommand = warmCommand;
    }
    /**
     * 开机
     */
    public void on(){
        onCommand.execute();
    }
    /**
     * 关机
     */
    public void off(){
        offCommand.execute();
    }
    public void warm(){
        warmCommand.execute();
    }
    public void cool(){
        coolCommand.execute();
    }
}
//使用
 public static void main(String[] args) {
        //创建接受者，空调就是接受者
        ConditionReceiver receiver = new ConditionReceiver();
        //创建命令对象，设置命令的接受者
        Command onCommand = new OnCommand(receiver);
        Command offCommand = new OffCommand(receiver);
        Command coolCommand = new CoolCommand(receiver);
        Command warmCommand = new WarmCommand(receiver);
        //创建请求者，把命令对象设置进去，app就是请求发起者
        AppInvoker appInvoker = new AppInvoker();
        appInvoker.setOnCommand(onCommand);
        appInvoker.setOffCommand(offCommand);
        appInvoker.setCoolCommand(coolCommand);
        appInvoker.setWarmCommand(warmCommand);
     
        appInvoker.on();
        System.out.println();
     
        appInvoker.cool();
        System.out.println();
        appInvoker.warm();
        System.out.println();     
        appInvoker.off();
 }
```

- 优点
  - 调用者角色与接收者角色之间没有任何依赖关系，不需要了解到底是哪个接收者执行，降低了系统耦合度
  - 扩展性强，新的命令可以很容易添加到系统中去。

- 缺点
  - 过多的命令模式会导致某些系统有过多的具体命令类

## IteratorPattern迭代器设计模式

- 迭代器设计模式（Iterator Pattern）

  - 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部实现，属于行为型模式
  - 应该是java中应用最多的设计模式之一

  ```
  提到迭代器，想到它是与集合相关的，集合也叫容器，可以将集合看成是一个可以包容对象的容器，例如List，Set，Map，甚至数组都可以叫做集合，迭代器的作用就是把容器中的对象一个一个地遍历出来
  ```

- 应用场景

  - 一般来说，迭代器模式是与集合是共存的，只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等 都有自己的迭代器
  - JAVA 中的 iterator迭代器

- 角色
  - 抽象容器（Aggregate）：提供创建具体迭代器角色的接口，一般是接口，包括一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。
  - 具体容器角色（ConcreteAggregate）：实现抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkedList, Set接口的哈希列表的实现HashSet等。
  - 抽象迭代器角色（Iterator）：负责定义访问和遍历元素的接口，包括几个核心方法，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移除当前对象的方法remove()
  - 具体迭代器角色（ConcreteIterator）：实现迭代器接口中定义的方法，并要记录遍历中的当前位置，完成集合的迭代

![image-20201012184722191](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201012184722191.png)

- 案例需求

```
自定义一个集合容器，并实现里面的迭代器功能，List集合容器的简化版本
```

- 编码实战

```java
public interface ICollection {
    void add(Object obj);
    void remove(Object obj);
    Iterator iterator();
}
public interface Iterator {
    /**
     * 获取下个元素
     * @return
     */
    Object next();
    /**
     * 是否有下一个
     * @return
     */
    boolean hasNext();
    /**
     * 删除元素
     * @param obj
     * @return
     */
    Object remove(Object obj);
}
public class ConcreteIterator implements Iterator{
    private List list;
    private int index = 0;
    public ConcreteIterator(List list){
        this.list = list;
    }
    @Override
    public Object next() {
        Object obj = null;
        if(this.hasNext()){
            obj = this.list.get(index);
            index++;
        }
        return obj;
    }

    @Override
    public boolean hasNext() {
        if(index == list.size()){
            return false;
        }
        return true;
    }

    @Override
    public Object remove(Object obj) {
        return list.remove(obj);
    }
}
public class MyCollection implements ICollection{
    private List list  = new ArrayList();
    @Override
    public void add(Object obj) {
        list.add(obj);
    }
    @Override
    public void remove(Object obj) {
        list.remove(obj);
    }
    @Override
    public Iterator iterator() {
        return new ConcreteIterator(list);
    }
}
//使用
public static void main(String[] args) {

        ICollection collection = new MyCollection();
        collection.add("小滴课堂老王");
        collection.add("小滴课堂Anna小姐姐");
        collection.add("小滴课堂二当家小D");
        collection.add("小滴课堂刘一手");
        collection.add("小滴课堂老帆");

        Iterator iterator = collection.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            System.out.println(obj);
        }
    }
```

- 优点

  - 可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据
  - 支持以不同的方式遍历一个聚合对象 

- 缺点

  - 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐
  - 迭代器模式在遍历的同时更改迭代器所在的集合结构会导致出现异常

- JDK源码 ArrayList的迭代器例子

  ![image-20201012184653205](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201012184653205.png)

## 备忘录设计模式

- 备忘录设计模式(Memento Pattern)
  - 在不破坏封闭的前提下，捕获一个对象的内部状态，保存对象的某个状态，以便在适当的时候恢复对象，又叫做快照模式，属于行为模式
  - 备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，

- 应用场景
  - 玩游戏的时候肯定有存档功能，下一次登录游戏时可以从上次退出的地方继续游戏
  - 棋盘类游戏的悔棋、数据库事务回滚
  - 需要记录一个对象的内部状态时，为了允许用户取消不确定或者错误的操作，能够恢复到原先的状态
  - 提供一个可回滚的操作，如ctrl+z、浏览器回退按钮

- 角色
  - Originator: 发起者，记录当前的内部状态，并负责创建和恢复备忘录数据，允许访问返回到先前状态所需的所有数据，可以根据需要决定Memento存储自己的哪些内部状态
  - Memento: 备忘录，负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态
  - Caretaker: 管理者，对备忘录进行管理、保存和提供备忘录，只能将备忘录传递给其他角色
  - Originator 和 Memento属性类似
- 需求背景

```
小滴课堂 - 二当家小D 开发了一个游戏存档功能 拳皇97，无限生命，每次快要死的的时候就恢复成刚开始的状态

使用备忘录设计模式帮他完成
```

- 编程实战

```java
public class RoleOriginator {
    /**
     * 生命力，会下降
     */
    private int live = 100;
    /**
     * 攻击力，会上涨
     */
    private int attack = 50;
    public int getLive() {
        return live;
    }
    public void setLive(int live) {
        this.live = live;
    }
    public int getAttack() {
        return attack;
    }
    public void setAttack(int attack) {
        this.attack = attack;
    }
    public void display(){
        System.out.println("开始=========");
        System.out.println("生命力："+live);
        System.out.println("攻击力："+attack);
        System.out.println("结束=========");
    }
    public void fight(){
        //攻击力会上涨
        this.attack = attack+2;
        //打架生命力会下降
        this.live = live - 10;
    }
    /**
     * 保存快照，存储状态
     * @return
     */
    public RoleStateMemento saveState(){
        return new RoleStateMemento(live,attack);
    }
    /**
     * 恢复
     */
    public void recoveryState(RoleStateMemento memento){
        this.attack = memento.getAttack();
        this.live = memento.getLive();
    }
}
public class RoleStateCaretaker {
    private RoleStateMemento memento;
    public RoleStateMemento getMemento() {
        return memento;
    }
    public void setMemento(RoleStateMemento memento) {
        this.memento = memento;
    }
}
public class RoleStateMemento {
    /**
     * 生命力，会下降
     */
    private int live;

    /**
     * 攻击力，会上涨
     */
    private int attack;

    public RoleStateMemento(int live, int attack) {
        this.live = live;
        this.attack = attack;
    }

    public int getLive() {
        return live;
    }

    public void setLive(int live) {
        this.live = live;
    }

    public int getAttack() {
        return attack;
    }

    public void setAttack(int attack) {
        this.attack = attack;
    }
}
//备忘录模式
RoleOriginator role = new RoleOriginator();
role.display();
role.fight();
role.display();
System.out.println("保存上面的快照");
RoleStateCaretaker caretaker = new RoleStateCaretaker();
caretaker.setMemento(role.saveState());
role.fight();
role.fight();
role.fight();
role.fight();
role.display();
System.out.println("准备恢复快照");
role.recoveryState(caretaker.getMemento());
role.display();
```

- 优点
  - 给用户提供了一种可以恢复状态的机制
  - 实现了信息的封装，使得用户不需要关心状态的保存细节

- 缺点
  - 消耗更多的资源，而且每一次保存都会消耗一定的内存

##  状态设计模式

- 状态设计模式(State Pattern)
  - 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为，属于行为型模式
  - 允许一个对象在其内部状态改变时改变它的行为
  - 状态模式是策略模式的孪生兄弟，它们的UML图是一样的，但实际上解决的是不同情况的两种场景问题
  - 工作中用的不多，基本策略模式比较多

![image-20201015191555656](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201015191555656.png)

- 应用场景
  - 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为
  - 代码中包含大量与对象状态有关的条件语句 ，比如一个操作中含有庞大的多分支的条件if else语句，且这些分支依赖于该对象的状态
  - 电商订单状态：未支付、已支付、派送中，收货完成等状态，各个状态下处理不同的事情

- 角色
  - Context 上下文: 定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理
  - State 抽象状态类: 定义一个接口以封装与Context的一个特定状态相关的行为。
  - ConcreteState具体状态类: 实现抽象状态定义的接口。

- 业务需求

```
电商订单状态流转，每步都有不同的操作内容: 新建订单/已支付/已发货/确认收货
```

 ![image-20201015191533278](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201015191533278.png)

- 编码实战

```java
public interface State {
    void handle();
}
public class NewOrderState implements State{
    @Override
    public void handle() {
        System.out.println("新订单，未支付");
        System.out.println("调用商户客服服务，有新订单\n");
    }
}
public class PayOrderState implements State{
    @Override
    public void handle() {
        System.out.println("新订单已经支付");
        System.out.println("调用商户客服服务，订单已经支付");
        System.out.println("调用物流服务，未发货\n");
    }
}
public class SendOrderState implements State{
    @Override
    public void handle() {
        System.out.println("订单已经发货");
        System.out.println("调用短信服务，告诉用户已经发货");
        System.out.println("更新物流信息\n");
    }
}
public class OrderContext {
    private State state;
    public OrderContext(){}

    public void setState(State state){
        this.state = state;
        System.out.println("订单状态变更！");
        this.state.handle();
    }
}
//使用
public static void main(String[] args) {
    OrderContext orderContext = new OrderContext();
    orderContext.setState(new NewOrderState());
    orderContext.setState(new PayOrderState());
    orderContext.setState(new SendOrderState());
}
```

- 优点
  - 只需要改变对象状态即可改变对象的行为
  - 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数

- 缺点
  - 状态模式的使用会增加系统类和对象的个数。
  - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱
  - 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码

- 状态设计和策略模式的区别
  - UML图一样，结构基本类似
  - 状态模式重点在各状态之间的切换，从而做不同的事情
  - 策略模式更侧重于根据具体情况选择策略，并不涉及切换
  - 状态模式不同状态下做的事情不同，而策略模式做的都是同一件事。例如，聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，但最终做的事情都是支付
  - 状态模式，各个状态的同一方法做的是不同的事，不能互相替

## 不常用的设计模式和学习建议

- 设计模式没有说一定是多少个，技术演进，模式也在不断更新
  - head first 设计模式、gof
- 像有些很少用的设计模式
  - 访问者模式、解释器模式、中介模式等，基本都用不上，简单知道就行的了
- 网上还有很多其他模式
  - MVC模式， Model-View-Controller（模型-视图-控制器）、传输模式等
  - 也有很多都是我们前面讲的模式组合或者变种
- 多看源码、网上的博文，多看几遍设计模式，这样反复才可以真正的体会到设计模式的好处
  - 一定不能固定死板
- 公司里面如果有重构需求（业务发展快的公司很多这样的需求，多发现原先存在的问题和结合设计模式的原则）

# 设计模式在框架和源码里面的应用

## **设计模式的在jdk源码的应用和Spring源码准备**

在jdk源码里面有多个设计模式

- 迭代器设计模式:Iterator类
- 装饰器模式：BufferedInputStream类
- 单例设计模式：JDK中Runtime类
- 建造者模式：StringBuilder类
- 适配器模式：JDBC数据库驱动
- 享元模式：JAVA 中的 String
- 策略设计模式 Comparator 接口常用的 compare()方法

Spring准备源码地址

- https://github.com/spring-projects/spring-framework
- 下载导入idea
- spring框架应用种设计模式：简单工厂模式、工厂方法模式、单例模式、代理模式、观察者模式 等等

![image-20201016164549895](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201016164549895.png)

- 设计模式：Comparator 接口常用的 compare()方法

## **单例模式在Spring框架里面的应用**

- scope属性值 singleton：单例, 默认值，调用getBean方法返回是同一个对象,实例会被缓存起来，效率比较高，当一个bean被标识为singleton时候，spring的IOC容器中只会存在一个该bean

```xml
<!--<bean id="video" class="net.xdclass.sp.domain.Video" scope="singleton"> -->
<bean id="video" class="net.xdclass.sp.domain.Video" scope="prototype">

        <property name="id" value="9"/>
        <property name="title" value="Spring 5.X课程" />

</bean>
```

- scope属性值 prototype: 多例，调用getBean方法创建不同的对象，会频繁的创建和销毁对象造成很大的开销

```java
 private static  void testScope(ApplicationContext context){
        Video  video1 = (Video)context.getBean("video");

        Video  video2 = (Video)context.getBean("video");

        //靠匹配内存地址，== 是匹配内存地址
        System.out.println( video1 == video2 );

  }
```

## 模板方法模式在Spring框架里面的应用之JDBCTemplate

- 模板方法模式在Spring源码JDBCTemplate的应用
- 入口

```
public List<Map<String, Object>> queryForList(String sql) 
```

![image-20201016202415503](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20201016202415503.png)

## 代理和策略模式在Spring框架里面的应用

- 程序代码里面的代理

```
什么是静态代理: 由程序创建或特定工具自动生成源代码，在程序运行前，代理类的.class文件就已经存在
 
什么是动态代理: 在程序运行时，运用反射机制动态创建而成，无需手动编写代码
  JDK动态代理
  CGLIB动态代理
```

- 两种动态代理的区别：
  - JDK动态代理：要求目标对象**实现一个接口**，但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以用CGLib动态代理
  - CGLib动态代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展
  - JDK动态代理是自带的，CGlib需要引入第三方包
  - CGLib动态代理基于继承来实现代理，所以无法对final类、private方法和static方法实现代理
- Spring AOP中的代理使用的默认策略：
  - 如果目标对象实现了接口，则默认采用JDK动态代理
  - 如果目标对象没有实现接口，则采用CgLib进行动态代理
  - 如果目标对象实现了接口，程序里面依旧可以指定使用CGlib动态代理
- 核心类

```
AopProxy

JdkDynamicAopProxy

CglibAopProxy

ProxyFactoryBean # protected Object getProxy(AopProxy aopProxy)
```