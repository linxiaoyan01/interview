# 面试题

## 简单题

### 合并两个链表

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);

        ListNode prev = prehead;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
}
```

### 最大子序和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int dp = nums[0];
        int maxSum = dp;

        //状态转移
        for(int i  = 1; i < nums.length; i++){
            dp = Math.max(dp + nums[i],nums[i]);
            maxSum = Math.max(maxSum, dp);
        }
        return maxSum;
    }
}
```

### 路径总和

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }
        if(root.left == null && root.right == null){
            return targetSum == root.val;
        }
        return (hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val));
    }
}
```

### 环形链表

```Java
//解法一 哈希函数 set集合判重
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}

//解法二 快慢指针
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

### 最小栈

```Java
class MinStack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
    
    public void pop() {
        xStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return xStack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

### 买卖股票的最佳时机

```java
//暴力解法
public class Solution {
    public int maxProfit(int prices[]) {
        int maxprofit = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                if (profit > maxprofit) {
                    maxprofit = profit;
                }
            }
        }
        return maxprofit;
    }
}
//一次遍历
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
```

### 验证回文串

时间复杂度为O(s) s表示字符串的长度

空间复杂度为O(1)

```java
class Solution {
    public boolean isPalindrome(String s) {
        int n = s.length();
        int left = 0, right = n - 1;
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                ++left;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                --right;
            }
            if (left < right) {
                if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                    return false;
                }
                ++left;
                --right;
            }
        }
        return true;
    }
}
```

### 反转链表

```java 
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}
```

## 中等题

### 二叉树的最近公共祖先

```java
class Solution {

    private TreeNode ans;

    public Solution() {
        this.ans = null;
    }

    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return false;
        boolean lson = dfs(root.left, p, q);
        boolean rson = dfs(root.right, p, q);
        if ((lson && rson) || ((root.val == p.val || root.val == q.val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root.val == p.val || root.val == q.val);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        this.dfs(root, p, q);
        return this.ans;
    }
}
```

### 二叉树的锯齿形层序遍历

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<List<Integer>>();
        if (root == null) {
            return ans;
        }

        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();
        nodeQueue.offer(root);
        boolean isOrderLeft = true;

        while (!nodeQueue.isEmpty()) {
            Deque<Integer> levelList = new LinkedList<Integer>();
            int size = nodeQueue.size();
            for (int i = 0; i < size; ++i) {
                TreeNode curNode = nodeQueue.poll();
                if (isOrderLeft) {
                    levelList.offerLast(curNode.val);
                } else {
                    levelList.offerFirst(curNode.val);
                }
                if (curNode.left != null) {
                    nodeQueue.offer(curNode.left);
                }
                if (curNode.right != null) {
                    nodeQueue.offer(curNode.right);
                }
            }
            ans.add(new LinkedList<Integer>(levelList));
            isOrderLeft = !isOrderLeft;
        }
        return ans;
    }
}
```

### 快排

```java
//递归
class Solution {
    public int[] sortArray(int[] nums) {
        return this.quickSort(nums,0,nums.length);
    }
    private int[] quickSort(int[] nums, int left, int right){
        if(right - left <= 1){
            return nums;
        }
        //选择最左边的元素构造子问题集合
        int x = nums[left];
        //小于x的放到左边，大于x的放到右边
        //int x = nums[left]
        //i代表x的位置
        int i = partition(nums,left,right);
        //省略计算x所在的位置i
        //以及将所有小于x的元素放到左边，大于x的元素放到右边
        //左闭右开 跳过x的位置
        quickSort(nums,left,i);
        quickSort(nums,i+1,right);
        return nums;
    }
    private int partition(int[] nums, int left, int right){
        int x = nums[left];

        //加一减一法
        //把不能确定的 确定
        //i指向左边不能确定的值 j指向右边不能确定的值
        int i = left + 1;
        int j = right;
        //x |--left--|--mid--|--right--|
        while(i != j){
            if(nums[i] < x){
                i++;
            }else{
                this.swap(nums, i, --j);
            }
        }
        //结束的时候要交换x和中间的值
        this.swap(nums, i-1, left);
        return i-1;
    }
    private void swap(int[] nums,int x,int y){
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }
}
```

### 二分法_搜索旋转排序数组

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

### 排序链表

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sortList(head, null);
    }
    public ListNode sortList(ListNode head, ListNode tail) {
        if (head == null) {
            return head;
        }
        if (head.next == tail) {
            head.next = null;
            return head;
        }
        ListNode slow = head, fast = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast != tail) {
                fast = fast.next;
            }
        }
        ListNode mid = slow;
        ListNode list1 = sortList(head, mid);
        ListNode list2 = sortList(mid, tail);
        ListNode sorted = merge(list1, list2);
        return sorted;
    }
    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}
```

### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Deque<Integer> stack1 = new LinkedList<Integer>();
        Deque<Integer> stack2 = new LinkedList<Integer>();
        while (l1 != null) {
            stack1.push(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            stack2.push(l2.val);
            l2 = l2.next;
        }
        int carry = 0;
        ListNode ans = null;
        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {
            int a = stack1.isEmpty() ? 0 : stack1.pop();
            int b = stack2.isEmpty() ? 0 : stack2.pop();
            int cur = a + b + carry;
            carry = cur / 10;
            cur %= 10;
            ListNode curnode = new ListNode(cur);
            curnode.next = ans;
            ans = curnode;
        }
        return ans;
    }
}
```

### 环形链表（要返回入环的第一个节点）空间要用 O(1)

```java
//哈希函数 O(n)  O(n)
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode pos = head;
        Set<ListNode> visited = new HashSet<ListNode>();
        while (pos != null) {
            if (visited.contains(pos)) {
                return pos;
            } else {
                visited.add(pos);
            }
            pos = pos.next;
        }
        return null;
    }
}
//快慢指针 O(n)  O(1)
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

### [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

```java
class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (nums[pivot] < nums[high]) {
                high = pivot;
            } else {
                low = pivot + 1;
            }
        }
        return nums[low];
    }
}
```

### 搜索旋转排序数组 II

````java
class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) {
            return false;
        }
        if (n == 1) {
            return nums[0] == target;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return true;
            }
            if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
                ++l;
                --r;
            } else if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return false;
    }
}
````

### 最长连续序列

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> num_set = new HashSet<Integer>();
        for (int num : nums) {
            num_set.add(num);
        }
        int longestStreak = 0;
        for (int num : num_set) {
            if (!num_set.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;
                while (num_set.contains(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }
                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }
        return longestStreak;
    }
}
```

### 最长连续上升子序列

```java
//很省空间的做法 时间O(n^2)
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        int maxLen = 1;
        int [] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        for(int j = 1; j < nums.length; j++){
            for(int i = 0; i < j; i++){
                if(nums[j] > nums[i]){
                    dp[j] = Math.max(dp[i] + 1, dp[j]);
                    maxLen = Math.max(maxLen, dp[j]);
                }
            } 
        }
        return maxLen;
    }
}
```

### [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
            return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (target < nums[mid] || (lower && target <= nums[mid])) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```

### [ 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```Java
//小顶堆
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(k);
        for (int i = 0; i < k; i++) {
            pq.add(nums[i]);
        }
        for (int i = k; i < nums.length; i++) {
            if (nums[i] > pq.peek()) {
                pq.remove();
                pq.add(nums[i]);
            }
        }
        return pq.peek();
    }
}
```

### 丑数

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] factors = {2, 3, 5};
        Set<Long> seen = new HashSet<Long>();
        PriorityQueue<Long> heap = new PriorityQueue<Long>();
        seen.add(1L);
        heap.offer(1L);
        int ugly = 0;
        for (int i = 0; i < n; i++) {
            long curr = heap.poll();
            ugly = (int) curr;
            for (int factor : factors) {
                long next = curr * factor;
                if (seen.add(next)) {
                    heap.offer(next);
                }
            }
        }
        return ugly;
    }
}
```

### 字符串解码

```java
class Solution {
    public String decodeString(String s) {
        Deque<Integer> times = new ArrayDeque<>();
        Deque<String> previousStrings = new ArrayDeque<>();
        //暂存"["后面的字母
        String res = "";
        //记录"["前面的数字
        int time = 0;
        
        for(char c : s.toCharArray()){
            if(Character.isDigit(c)){
                time = time * 10 + Integer.parseInt(c + "");
            }else if(c == '['){
                times.push(time);
                previousStrings.push(res);
                //重置 
                time = 0;
                res = "";
            }else if(c == ']'){
                int currentTime = times.pop();
                String previousString = previousStrings.pop();
                while(currentTime > 0){
                    previousString += res;
                    currentTime--;
                }
                res = previousString;
            }else{
                res += c;
            }
        }
        return res;
    }
}
```

### [用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

```java
class Solution extends SolBase {
    public int rand10() {
        int row, col, idx;
        do {
            row = rand7();
            col = rand7();
            idx = col + (row - 1) * 7;
        } while (idx > 40);
        return 1 + (idx - 1) % 10;
    }
}
```

### LRU缓存机制

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

### 从前序与中序遍历构造序列二叉树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;
        if(preLen != inLen){
            throw new  RuntimeException("Incorrect input data.");
        }
        Map<Integer, Integer> map = new HashMap<>(preLen);
        for(int i = 0; i < inLen; i++){
            map.put(inorder[i],i);
        }
        return buildTree(preorder, 0, preLen - 1, map, 0, inLen - 1);
    }
    private TreeNode buildTree(int[] preorder, int preLeft, int preRight, Map<Integer,Integer>map, int inLeft, int inRight){
        if(preLeft > preRight || inLeft > inRight){
            return null;
        }
        int rootVal = preorder[preLeft];
        TreeNode root = new TreeNode(rootVal);
        int pIndex = map.get(rootVal);
        root.left = buildTree(preorder, preLeft + 1, pIndex - inLeft + preLeft, map, inLeft, pIndex-1);
        root.right = buildTree(preorder, pIndex - inLeft + preLeft + 1, preRight, map, pIndex + 1, inRight);
        return root;
    }
}
```

### 删除链表的倒数第N个节点

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode first = head;
        ListNode second = dummy;
        for (int i = 0; i < n; ++i) {
            first = first.next;
        }
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}
```

### 按序打印

```java
class Foo {

  private AtomicInteger firstJobDone = new AtomicInteger(0);
  private AtomicInteger secondJobDone = new AtomicInteger(0);

  public Foo() {}

  public void first(Runnable printFirst) throws InterruptedException {
    // printFirst.run() outputs "first".
    printFirst.run();
    // mark the first job as done, by increasing its count.
    firstJobDone.incrementAndGet();
  }

  public void second(Runnable printSecond) throws InterruptedException {
    while (firstJobDone.get() != 1) {
      // waiting for the first job to be done.
    }
    // printSecond.run() outputs "second".
    printSecond.run();
    // mark the second as done, by increasing its count.
    secondJobDone.incrementAndGet();
  }

  public void third(Runnable printThird) throws InterruptedException {
    while (secondJobDone.get() != 1) {
      // waiting for the second job to be done.
    }
    // printThird.run() outputs "third".
    printThird.run();
  }
}
```

### 用栈实现队列

```java
private int front;
Stack<Integer> stack1;
Stack<Integer> stack2;
/** Initialize your data structure here. */
public MyQueue() {
    stack1 = new Stack<>();
    stack2 = new Stack<>();
}
public void push(int x) {
    if (s1.empty())
        front = x;
    while (!s1.isEmpty())
        s2.push(s1.pop());
    s2.push(x);
    while (!s2.isEmpty())
        s1.push(s2.pop());
}
// Removes the element from the front of queue.
public void pop() {
    s1.pop();
    if (!s1.empty())
        front = s1.peek();
}
// Return whether the queue is empty.
public boolean empty() {
    return s1.isEmpty();
}
// Get the front element.
public int peek() {
  return front;
}
```

### 最长回文子串

```java
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

### 比较版本号

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        for (int i = 0; i < v1.length || i < v2.length; ++i) {
            int x = 0, y = 0;
            if (i < v1.length) {
                x = Integer.parseInt(v1[i]);
            }
            if (i < v2.length) {
                y = Integer.parseInt(v2[i]);
            }
            if (x > y) {
                return 1;
            }
            if (x < y) {
                return -1;
            }
        }
        return 0;
    }
}
```

### 二叉树的右视图

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            //当前层创建下一层，创建之后要一起添加到queue，不能直接添加到queue，因为要获取这一层最后queue最后一个node，若是不用while用for循环queue的size就不用创建nextlevel吧
            Queue<TreeNode> nextLevel = new LinkedList<>();
            int lastVal = 0;
            while(!queue.isEmpty()){
                TreeNode cur = queue.poll();
                lastVal = cur.val;
                if(cur.left != null) nextLevel.offer(cur.left);
                if(cur.right != null) nextLevel.offer(cur.right);
            }
            res.add(lastVal);
            queue.addAll(nextLevel);
        }
        return res;
    }
}
```

# 365道高频算法题

## 刷题第一天

### 1. 数组中重复数字

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < nums.length; i++){
            int index = Math.abs(nums[i]) - 1;
            if(nums[index] < 0){
                res.add(Math.abs(nums[i]));
            }else{
                nums[index] = -nums[index];
            }
        }
        return res;
        
    }
}
```

### 2. 消失的数字

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; i++){
            int index = (nums[i] - 1) % n;
            nums[index] += n;
        }
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < n; i++){
            if(nums[i] <= n){
                res.add(i+1);
            }
        }
        return res;
    }
}
```

### 3. 查找常用字符

```java
class Solution {
    public List<String> commonChars(String[] words) {
        int[] minfreq = new int[26];
        Arrays.fill(minfreq, Integer.MAX_VALUE);
        for (String word : words) {
            int[] freq = new int[26];
            int length = word.length();
            for (int i = 0; i < length; ++i) {
                char ch = word.charAt(i);
                ++freq[ch - 'a'];
            }
            for (int i = 0; i < 26; ++i) {
                minfreq[i] = Math.min(minfreq[i], freq[i]);
            }
        }

        List<String> ans = new ArrayList<String>();
        for (int i = 0; i < 26; ++i) {
            for (int j = 0; j < minfreq[i]; ++j) {
                ans.add(String.valueOf((char) (i + 'a')));
            }
        }
        return ans;
    }
}
```

### 4. 上升下降字符串

```java
class Solution {
    public String sortString(String s) {
        int[] num = new int[26];
        for (int i = 0; i < s.length(); i++) {
            num[s.charAt(i) - 'a']++;
        }

        StringBuffer ret = new StringBuffer();
        while (ret.length() < s.length()) {
            for (int i = 0; i < 26; i++) {
                if (num[i] > 0) {
                    ret.append((char) (i + 'a'));
                    num[i]--;
                }
            }
            for (int i = 25; i >= 0; i--) {
                if (num[i] > 0) {
                    ret.append((char) (i + 'a'));
                    num[i]--;
                }
            }
        }
        return ret.toString();
    }
}
```

### 5. 删除有序数组中的重复项

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast < nums.length){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```

### 6. 移动零

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if(nums.length == 0) return;
        int slow = 0;
        int fast = 0;
        while(fast < nums.length){
            if(nums[fast]!=0){
                nums[slow] = nums[fast];
                slow++;
            } 
            fast++;
        }
        for(int i = slow; i < nums.length; i++){
            nums[i] = 0;
        }
    }
}
```

### 7. 删除排序数组中的重复元素二

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length <= 2){
            return nums.length;
        }
        int slow = 2;
        int fast = 2;
        while(fast < nums.length){
            if(nums[fast] != nums[slow -2]){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

### 8. 移除元素

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;
        int left = 0;
        for (int right = 0; right < n; right++) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
        }
        return left;
    }
}
//对撞指针
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length == 0){
            return 0;
        }
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            if(nums[left] == val){
                nums[left] = nums[right];
                right--;
            }else{
                left++;
            }
        }
        return right+1;
    }
}
```

### 9. 反转字符串

```java
class Solution {
    public void reverseString(char[] s) {
        int n = s.length;
        for (int left = 0, right = n - 1; left < right; ++left, --right) {
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
        }
    }
}
```

### 10. 盛最多水的容器

```java
public class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int area = Math.min(height[l], height[r]) * (r - l);
            ans = Math.max(ans, area);
            if (height[l] <= height[r]) {
                ++l;
            }
            else {
                --r;
            }
        }
        return ans;
    }
}
```

### 11. 一维数组的动态和

```java
class Solution {
    public int[] runningSum(int[] nums) {
        if(nums.length == 0 && nums.length == 1){
            return nums;
        }
        int slow = 0;
        int fast = 0;
        int[] ans = new int[nums.length];
        while(fast < nums.length){
            if(fast == 0){
                ans[fast] = nums[fast];
                fast++;
            }else{
                ans[fast] = ans[slow]+nums[fast];
                slow++;
                fast++;
            }
        }
        return ans;
    }
}
```

### 12. 除自身以外数组的乘积

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] answer = new int[length];

        // answer[i] 表示索引 i 左侧所有元素的乘积
        // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
        answer[0] = 1;
        for (int i = 1; i < length; i++) {
            answer[i] = nums[i - 1] * answer[i - 1];
        }

        // R 为右侧所有元素的乘积
        // 刚开始右边没有元素，所以 R = 1
        int R = 1;
        for (int i = length - 1; i >= 0; i--) {
            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
            answer[i] = answer[i] * R;
            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
            R *= nums[i];
        }
        return answer;
    }
}
```

## 刷题第二天

### 1. 有效的山脉数组

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        int n = arr.length;
        int i = 0;
        while(i < n-1 &&  arr[i] < arr[i + 1]){
            i++;
        }
        if(i == 0 || i == n - 1){
            return false;
        }
        while(i < n-1 && arr[i] > arr[i+1]){
            i++;
        }
        return i == n-1;
    }
}
```

### 2. 旋转数组

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length-1);
    }
    public void reverse(int[] nums, int start, int end){
        while(start < end){
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}
//环状替换
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k  = k % n;
        int count = 0;
        for(int start = 0; count < n; start++){
            int curr =  start;
            //保存要被替换的位置上的值
            int prev = nums[start];
            //循环替换
            do{
                int next = (curr + k) % n;
                int tmp = nums[next];
                nums[next] = prev;
                
                curr = next;
                count++;
            }while(start != curr);
        }
    }
}
```

### 3. 非递减数组

````java
class Solution {
    public boolean checkPossibility(int[] nums) {
        int cnt = 0;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < nums[i - 1]) {
                cnt++;
                if (cnt > 1) return false;
                if (i - 2 >= 0 && nums[i] < nums[i - 2]) {
                    nums[i] = nums[i - 1];
                }
            }
        }
        return true;
    }
}
````

### 4. 汇总区间

```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> ret = new ArrayList<String>();
        int i = 0;
        int n = nums.length;
        while (i < n) {
            int low = i;
            i++;
            while (i < n && nums[i] == nums[i - 1] + 1) {
                i++;
            }
            int high = i - 1;
            StringBuffer temp = new StringBuffer(Integer.toString(nums[low]));
            if (low < high) {
                temp.append("->");
                temp.append(Integer.toString(nums[high]));
            }
            ret.add(temp.toString());
        }
        return ret;
    }
}
```

### 5. 缺失的区间

```java
class Solution {
    public List<String> findMissingRanges(int[] nums, int lower, int upper){
		List<String> res = new ArrayList<>();
        long pre = lower - 1;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == pre + 2){
                res.add(String.valueOf(pre + 1));
            }else if(nums[i] > pre + 2){
                res.add((pre + 1) + "->" + (nums[i] - 1));
            }
            pre = nums[i];
        }
        if(upper == pre + 1){
            res.add(String.valueOf(pre + 1));
        }else if(upper > pre + 1){
            res.add((pre + 1) + "->" + upper);
        }
        return res;
    }
}
```

### 6. 下一个排列

```java
class Solution {
    public void nextPermutation(int[] nums) {
        // 1. 找到尽量靠右的【较小数】
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) i--;

        // 2. 如果找到了【较小数】
        if (i >= 0) {
            // 找到尽量靠右的【较大数】
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) j--;

            // 交换【较小数】和【较大数】
            swap(nums, i, j);
        }

        // 3. 反转【较小数】 i 之后的所有元素
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### 7. 分发糖果

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] left = new int[n];
        for (int i = 0; i < n; i++) {
            if (i > 0 && ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            } else {
                left[i] = 1;
            }
        }
        int right = 0, ret = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (i < n - 1 && ratings[i] > ratings[i + 1]) {
                right++;
            } else {
                right = 1;
            }
            ret += Math.max(left[i], right);
        }
        return ret;
    }
}
```

### 8. 种花问题

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        if (flowerbed == null || flowerbed.length == 0) return n == 0;
        // 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0
        int countOfZero = 1; 
        // 可以种的花的数量
        int canPlace = 0; 
        for (int bed : flowerbed) {
            // 遇到0，连续0的数量+1
            if (bed == 0) { 
                countOfZero++;
            } else { // 遇到1，结算上一段连续的0区间，看能种下几盆花：(countOfZero-1)/2
                canPlace += (countOfZero-1)/2;
                if (canPlace >= n) return true;
                countOfZero = 0; // 0的数量清零，开始统计下一个全0分区
            }
        }
        // 最后一段0区还未结算：
        countOfZero++; // 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0
        canPlace += (countOfZero-1)/2;

        return canPlace >= n;
    }
}
```

### 9. 柠檬水找零

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0, ten = 0;
        for (int bill : bills) {
            if (bill == 5) {
                five++;
            } else if (bill == 10) {
                if (five == 0) {
                    return false;
                }
                five--;
                ten++;
            } else {
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 10. 解码方法二

```java
class Solution {
    static final int MOD = 1000000007;

    public int numDecodings(String s) {
        int n = s.length();
        // a = f[i-2], b = f[i-1], c = f[i]
        long a = 0, b = 1, c = 0;
        for (int i = 1; i <= n; ++i) {
            c = b * check1digit(s.charAt(i - 1)) % MOD;
            if (i > 1) {
                c = (c + a * check2digits(s.charAt(i - 2), s.charAt(i - 1))) % MOD;
            }
            a = b;
            b = c;
        }
        return (int) c;
    }

    public int check1digit(char ch) {
        if (ch == '0') {
            return 0;
        }
        return ch == '*' ? 9 : 1;
    }

    public int check2digits(char c0, char c1) {
        if (c0 == '*' && c1 == '*') {
            return 15;
        }
        if (c0 == '*') {
            return c1 <= '6' ? 2 : 1;
        }
        if (c1 == '*') {
            if (c0 == '1') {
                return 9;
            }
            if (c0 == '2') {
                return 6;
            }
            return 0;
        }
        return (c0 != '0' && (c0 - '0') * 10 + (c1 - '0') <= 26) ? 1 : 0;
    }
}
```

## 刷题第三天

### 1. 转置矩阵

```java
class Solution {
    public int[][] transpose(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] transposed = new int[n][m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        return transposed;
    }
}
```

### 3. 旋转图像

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        //水平翻转
        for(int i = 0; i < n /2; i++){
            for(int j = 0; j < n; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i -1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        //原地对角线翻转 即原地转置 与申请一个新数组来转置不同，若是新数组，j < n，但这里要注意是 j < i
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```

### 4. 有效的数独

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] columns = new int[9][9];
        int[][][] subboxes = new int[3][3][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

### 5. 矩阵置零

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

### 6. 螺旋矩阵

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int row = 0, column = 0;
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order.add(matrix[row][column]);
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
}
```

### 7. 螺旋矩阵二

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int maxNum = n * n;
        int curNum = 1;
        int[][] matrix = new int[n][n];
        int row = 0, column = 0;
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // 右下左上
        int directionIndex = 0;
        while (curNum <= maxNum) {
            matrix[row][column] = curNum;
            curNum++;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= n || nextColumn < 0 || nextColumn >= n || matrix[nextRow][nextColumn] != 0) {
                directionIndex = (directionIndex + 1) % 4; // 顺时针旋转至下一个方向
            }
            row = row + directions[directionIndex][0];
            column = column + directions[directionIndex][1];
        }
        return matrix;
    }
}
```

### 8. 对角线遍历

```java
class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {
        if (matrix.length == 0) return new int[0];

        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dirs = {{-1, 1}, {1, -1}};

        int row = 0, col = 0, di = 0;
        int[] result = new int[m * n];
        for (int i = 0; i < m * n; i++) {
            result[i] = matrix[row][col];

            row = row + dirs[di][0];
            col = col + dirs[di][1];

            if (col >= n) {col = n - 1; row += 2; di = 1 - di;}
            if (row >= m) {row = m - 1; col += 2; di = 1 - di;}
            if (row < 0) {row = 0; di = 1 - di;}
            if (col < 0) {col = 0; di = 1 - di;}
        }
        return result;
    }
}
```

### 9. 杨辉三角

```javascript
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        for (int i = 0; i < numRows; ++i) {
            List<Integer> row = new ArrayList<Integer>();
            for (int j = 0; j <= i; ++j) {
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j));
                }
            }
            ret.add(row);
        }
        return ret;
    }
}
```

### 10. 杨辉三角二

```java
//滚动数组
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> pre = new ArrayList<Integer>();
        for (int i = 0; i <= rowIndex; ++i) {
            List<Integer> cur = new ArrayList<Integer>();
            for (int j = 0; j <= i; ++j) {
                if (j == 0 || j == i) {
                    cur.add(1);
                } else {
                    cur.add(pre.get(j - 1) + pre.get(j));
                }
            }
            pre = cur;
        }
        return pre;
    }
}
```

## 刷题第四天

### 1, 实现 strStr()

```java
//暴力解法
class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), m = needle.length();
        for (int i = 0; i + m <= n; i++) {
            boolean flag = true;
            for (int j = 0; j < m; j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return i;
            }
        }
        return -1;
    }
}
```

### 2. 重复的子字符串

```Java
//双指针模拟
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        for (int i = 1; i * 2 <= n; ++i) {
            if (n % i == 0) {
                boolean match = true;
                for (int j = i; j < n; ++j) {
                    if (s.charAt(j) != s.charAt(j - i)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

### 3. 字符串反转

```java
class Solution {
    public void reverseString(char[] s) {
        int n = s.length;
        for(int left = 0, right = n - 1; left < right; left++, right--){
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
        }
    }
}
```

### 4. [反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

```java
class Solution {
    public String reverseVowels(String s) {
        int n = s.length();
        char[] arr = s.toCharArray();
        int i = 0, j = n - 1;
        while (i < j) {
            while (i < n && !isVowel(arr[i])) {
                ++i;
            }
            while (j > 0 && !isVowel(arr[j])) {
                --j;
            }
            if (i < j) {
                swap(arr, i, j);
                ++i;
                --j;
            }
        }
        return new String(arr);
    }

    public boolean isVowel(char ch) {
        return "aeiouAEIOU".indexOf(ch) >= 0;
    }

    public void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 5. 删去字符串的元音字母

```java
public String remove(String s){
    StringBuilder res = new StringBuilder();
    for(char c : s.toCharArray()){
        if(!isVowel(c)){
            res.append(c);
        }
    }
    return res.toString();
}
public boolean isVowel(char ch) {
        return "aeiouAEIOU".indexOf(ch) >= 0;
}
```

### 6. 反转字符串二

```java
class Solution {
    public String reverseStr(String s, int k) {
        int n = s.length();
        char[] arr = s.toCharArray();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(arr, i, Math.min(i + k, n) - 1);
        }
        return new String(arr);
    }

    public void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}
```

### 7. [反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

```java
class Solution {
    public String reverseWords(String s) {
        char[] chars = s.toCharArray();
        int n = chars.length;

        int left = 0;
        while(left < n){
            if(chars[left] != ' '){
                int right = left;
                while(right + 1 < n && chars[right + 1] != ' '){
                    right++;
                }
                reverse(chars, left, right);
                left = right+1;
            }else{
                left++;
            }
        }
        return new String(chars);
    }
    public void reverse(char[] chars, int left, int right){
        while(left < right){
            char temp = chars[right];
            chars[right] = chars[left];
            chars[left] = temp;
            left++;
            right--;
        }
    }
}
```

### 8. 最后一个单词的长度

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int index = s.length() - 1;
        while (s.charAt(index) == ' ') {
            index--;
        }
        int wordLength = 0;
        while (index >= 0 && s.charAt(index) != ' ') {
            wordLength++;
            index--;
        }
        return wordLength;
    }
}
```

### 9. 字符串转换整数

```java
//自动机
class Solution {
    public int myAtoi(String str) {
        Automaton automaton = new Automaton();
        int length = str.length();
        for (int i = 0; i < length; ++i) {
            automaton.get(str.charAt(i));
        }
        return (int) (automaton.sign * automaton.ans);
    }
}

class Automaton {
    public int sign = 1;
    public long ans = 0;
    private String state = "start";
    private Map<String, String[]> table = new HashMap<String, String[]>() {{
        put("start", new String[]{"start", "signed", "in_number", "end"});
        put("signed", new String[]{"end", "end", "in_number", "end"});
        put("in_number", new String[]{"end", "end", "in_number", "end"});
        put("end", new String[]{"end", "end", "end", "end"});
    }};

    public void get(char c) {
        state = table.get(state)[get_col(c)];
        if ("in_number".equals(state)) {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? Math.min(ans, (long) Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE);
        } else if ("signed".equals(state)) {
            sign = c == '+' ? 1 : -1;
        }
    }

    private int get_col(char c) {
        if (c == ' ') {
            return 0;
        }
        if (c == '+' || c == '-') {
            return 1;
        }
        if (Character.isDigit(c)) {
            return 2;
        }
        return 3;
    }
}
```

### 10. 比较版本号

```java
//双指针
class Solution {
    public int compareVersion(String version1, String version2) {
        int n = version1.length(), m = version2.length();
        int i = 0, j = 0;
        while (i < n || j < m) {
            int x = 0;
            for (; i < n && version1.charAt(i) != '.'; ++i) {
                x = x * 10 + version1.charAt(i) - '0';
            }
            ++i; // 跳过点号
            int y = 0;
            for (; j < m && version2.charAt(j) != '.'; ++j) {
                y = y * 10 + version2.charAt(j) - '0';
            }
            ++j; // 跳过点号
            if (x != y) {
                return x > y ? 1 : -1;
            }
        }
        return 0;
    }
}
```

### 11. 整数转罗马数字

```java
class Solution {
    int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    public String intToRoman(int num) {
        StringBuffer roman = new StringBuffer();
        for (int i = 0; i < values.length; ++i) {
            int value = values[i];
            String symbol = symbols[i];
            while (num >= value) {
                num -= value;
                roman.append(symbol);
            }
            if (num == 0) {
                break;
            }
        }
        return roman.toString();
    }
}
```

### 12. 罗马数字转整数

```java
class Solution {
    Map<Character, Integer> symbolValues = new HashMap<Character,Integer>(){{
            put('I',1);
            put('V',5);
            put('X',10);
            put('L',50);
            put('C',100);
            put('D',500);
            put('M',1000);
        }};
    public int romanToInt(String s) {
       int sum = 0;
       int n = s.length();

       int pre = symbolValues.get(s.charAt(0));
       for(int i = 1; i < n; i++){
           int curr = symbolValues.get(s.charAt(i));
           if(pre < curr){
               sum -= pre;
           }else{
               sum += pre;
           }
           pre = curr;
       }
        sum += pre;
        return sum;
    }
}
```

### 13. Z字形变换

```java
//按行访问
class Solution {
    public String convert(String s, int numRows) {
        if(numRows == 1){
            return s;
        }
        StringBuilder sb = new StringBuilder();
        int delta = 2 * numRows - 2;

        int  n = s.length();

        for(int row = 0; row < numRows; row++){
            for(int col = 0; col + row < n; col += delta){
                sb.append(s.charAt(col+row));
                if(row != 0 && row != numRows - 1 && col + delta -row < n){
                    sb.append(s.charAt(col + delta -row));
                }
            }
        }
        return sb.toString();  
    }
}
```

## 刷题第五天

### 1. 整数反转

```java
// 方法二：溢出之后判断
public int reverse(int x) {
    int res = 0;
    while (x != 0) {
        int pop = x % 10;
        x = x / 10;
        int newRes = res * 10 + pop;
        if ((newRes - pop) / 10 != res) return 0;
        res = newRes;
    }
    return res;
}
// 方法一：溢出之前判断
public int reverse2(int x) {
    int res = 0;
    while (x != 0) {
        int pop = x % 10;
        x = x / 10;
        // MAX_VALUE = 2^31 - 1 = 2147483647
        if (res > Integer.MAX_VALUE / 10
            || (res == Integer.MAX_VALUE / 10 && pop > 7)) return 0; // bug 修复：这里是除以 10
        // MIN_VALUE = -2^31 = -2147483648
        if (res < Integer.MIN_VALUE / 10
            || (res == Integer.MIN_VALUE  / 10 && pop < -8)) return 0;
        res = res * 10 + pop;
    }
    return res;
}
```

### 2. 回文数

```java
class Solution {
    public boolean isPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber / 10;
    }
}
```

### 3. 数组形式的整数加法

```java
class Solution {
    public List<Integer> addToArrayForm(int[] A, int K) {
        List<Integer> res = new ArrayList<>();
        int carry = 0;
        int l1 = A.length - 1;
        while (l1 >= 0 || K != 0) {
            int x = l1 < 0 ? 0 : A[l1];
            int y = K == 0 ? 0 : K % 10;

            int sum = x + y + carry;
            res.add(sum % 10);
            carry = sum / 10;

            l1--;
            K = K / 10;
        }
        if (carry != 0) res.add(carry);
        Collections.reverse(res);
        return res;
    }
}
```

### 4. 加一

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            digits[i]++;
            digits[i] = digits[i] % 10;
            if (digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
}
```

### 5.  字符串相加

```java
public String addStrings(String num1, String num2) {
    StringBuilder res = new StringBuilder();
    int carry = 0;
    int l1 = num1.length() - 1;
    int l2 = num2.length() - 1;
    while (l1 >= 0 || l2 >= 0) {
        int x = l1 < 0 ? 0 : num1.charAt(l1) - '0';
        int y = l2 < 0 ? 0 : num2.charAt(l2) - '0';
        
        int sum = x + y + carry;
        res.append(sum % 10);
        carry = sum / 10;

        l1--;
        l2--;
    }
    if (carry != 0) res.append(carry);
    return res.reverse().toString();
}
```

### 6. 二进制求和

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder res = new StringBuilder();
        int carry = 0;
        int l1 = a.length() - 1;
        int l2 = b.length() - 1;
        while(l1 >= 0 || l2 >= 0){
            int x = l1 < 0 ? 0 :a.charAt(l1) - '0';
            int y = l2 < 0 ? 0 :b.charAt(l2) - '0';
            int sum = x + y + carry;
            //只需要将10改为2
            res.append(sum % 2);
            carry = sum / 2;
            l1--;
            l2--;
        }
        if(carry != 0){
            res.append(carry);
        } 
        return res.reverse().toString();
    }
}
```

### 7. 两数相加

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode();
        ListNode curr = dummy;

        int carry = 0;

        while(l1 != null || l2 != null){
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;

            int sum = x + y + carry;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            carry = sum / 10;

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;

        }
        if(carry != 0){
            curr.next = new ListNode(carry);
        } 
        return dummy.next;
    }
}
```

### 8. 字符串相乘

```java
public String multiply(String num1, String num2) {
    if (num1.equals("0") || num2.equals("0")) return "0";

    int m = num1.length(), n = num2.length();
    int[] res = new int[m + n];

    for (int i = m - 1; i >= 0; i--) {
        int x = num1.charAt(i) - '0';
        for (int j = n - 1; j >= 0; j--) {
            int y = num2.charAt(j) - '0';
            int sum = res[i + j + 1] + x * y;
            res[i + j + 1] = sum % 10;
            res[i + j] += sum / 10;
        }
    }

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < res.length; i++) {
        if (i == 0 && res[i] == 0) continue;
        sb.append(res[i]);
    }
    return sb.toString();
}
```

### 9. 计数质数

```java
class Solution {
    public int countPrimes(int n) {
        int[] isPrime = new int[n];
        Arrays.fill(isPrime, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i] == 1) {
                ans += 1;
                if ((long) i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
}
```

### 10. 数字1的个数

```java
class Solution {
    public int countDigitOne(int n) {
		int count = 0;
        // bug 修复：i 应该是长整型，要不然会溢出
        for (long i = 1; i <= n; i *= 10) {
            // (n/10)*1 + min(max((n%10 - 1 + 1), 0), 1)
            // (n/100)*10 + min(max((n%100 - 10 + 1), 0), 10)
            // (n/1000)*100 + min(max((n%1000 - 100 + 1), 0), 100)
            long divider = i * 10;
            count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0L), i);
        }
        return count;
    }
}
```

### 11. 缀点成线

```java
class Solution {
    public boolean checkStraightLine(int[][] coordinates) {
        int x0 = coordinates[0][0];
        int y0 = coordinates[0][1];

        int deltaX = coordinates[1][0] - x0;
        int deltaY = coordinates[1][1] - y0;
        for(int i = 2; i < coordinates.length; i++){
            int deltaYi = coordinates[i][1] - y0;
            int deltaXi = coordinates[i][0] - x0;

            if(deltaY * deltaXi != deltaYi * deltaX){
                return false;
            }
        
        }
        return true;
    }
}
```

## 刷题第六天

### 1. 位1的个数

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while(n != 0){
            //去掉最后一位1
            n &= n - 1;
            res++;
        }
        return res;
    }
}
```

### 2. 汉明距离

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s != 0) {
            s &= s - 1;
            ret++;
        }
        return ret;
    }
}
```

### 3. 汉明距离总和

```java
class Solution {
    public int totalHammingDistance(int[] nums) {
        int ans = 0, n = nums.length;
        for (int i = 0; i < 30; ++i) {
            int c = 0;
            for (int val : nums) {
                c += (val >> i) & 1;
            }
            ans += c * (n - c);
        }
        return ans;
    }
}
```

### 4. 2的幂

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n == 0){
            return false;
        }
        //当 n = -2147483648的时候， n - 1 就会溢出
        long x = n;
        return (x & (x - 1)) == 0;
    }
}
```

### 5. 两整数之和

```java
class Solution {
    public int getSum(int a, int b) {
        while(b != 0){
            int carry = (a & b) << 1;
            a = a ^ b;
            b = carry;
        }
        return a;
    }
}
```

### 6. 两数相除

![image-20210930212400452](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930212540.png)

![image-20210930212535116](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930212546.png)

b左移31位是会越界的，那怎么解决左移越界的问题？其实要比较a，b左移后的数字，就相当是比较a右移后的数字和b

若a为负最大值，那么abs(a)还是负最大值，且负最大值右移是负数，为了把a看成整数，采用把a无符号右移$i$位

![image-20210930213631921](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930213657.png)

且要注意，任何数减去最小值还是最小值，所以可以将b移动大于等于符号的左边，才能正好把b当成正数看待，这样就能规避了把b看成最小值的情况

![image-20210930213829451](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210930213833.png)

```java
//O(1)
class Solution {
    public int divide(int a, int b) {
        if (a == Integer.MIN_VALUE && b == -1)
            return Integer.MAX_VALUE;
        int sign = (a > 0) ^ (b > 0) ? -1 : 1;
        a = Math.abs(a);
        b = Math.abs(b);
        int res = 0;
        for (int i = 31; i >= 0; i--) {
            // 首先，右移的话，再怎么着也不会越界
            // 其次，无符号右移的目的是：将 -2147483648 看成 2147483648

            // 注意，这里不能是 (a >>> i) >= b 而应该是 (a >>> i) - b >= 0
            // 这个也是为了避免 b = -2147483648，如果 b = -2147483648
            // 那么 (a >>> i) >= b 永远为 true，但是 (a >>> i) - b >= 0 为 false
            if ((a >>> i) - b >= 0) { // a >= (b << i)
                a -= (b << i);
                res += (1 << i);
            }
        }
        // bug 修复：因为不能使用乘号，所以将乘号换成三目运算符
        return sign == 1 ? res : -res;
    }
}
```

### 7. 只出现过一次的数字

![image-20211001080952008](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001084342.png)

```Java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for(int num : nums){
            single ^= num;
        }
        return single;
    }
}
```

哈希查找（使用容器）和异或去重的思想一一致

![image-20211001081412672](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001084335.png)

### 8. 只出现过一次的数字二

如果1的个数不是3的倍数，说明那个只出现一次的数字的二进制中在着一位是1

![image-20211001084314717](C:/Users/86158/AppData/Roaming/Typora/typora-user-images/image-20211001084314717.png)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int i = 0; i < 32; i++){
            int oneCount = 0;
            for(int num: nums){
                oneCount += (num >> i) & 1;
            }
            if(oneCount % 3 != 0){
                res |= 1 << i;
            }
        }
        return res;
    }
}
```

### 9. 只出现过一次的数字三

![image-20211001092130656](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001092143.png)

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int bitmask = 0;
        //全部进行异或，得到两个出现一次的数字的异或结果
        for(int num : nums){
            bitmask ^= num;
        }
        //取到两个出现一次的数字的异或结果的最后一个1
        int diff = bitmask & (-bitmask);

        //分组
        int[] ans = new int[2];
        
        for(int num : nums){
            if((num & diff) != 0){
                ans[0] ^= num;
            }else{
                ans[1] ^= num;
            }
        }
        return ans;
    }
}
```

### 10. 或运算的最小翻转次数

将a和b或运算后的结果与c对比，找出哪些位不同，方法是通过将或运算的结果与c异或，不同位就能找到，结合a和b就知道a和b在这一位上翻转几次

![image-20211001094053080](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001094056.png)

```java
class Solution {
    public int minFlips(int a, int b, int c) {
        int aOrb = a | b;
        int equal = aOrb ^ c;
        if(equal == 0){
            return 0;
        }

        int ans = 0;
        for(int i = 0; i < 31; i++){
            int mask = 1 << i;
             // a | b 和 c 的第 i 位不同，那么至少需要翻转 1 次
            if((equal & mask) > 0){
                if((c & mask) == 0 && (a & mask) == (b & mask)){
                    ans += 2;
                }else{
                    ans += 1;
                }
            }
        }
        return ans;
    }
}
```

### 11. 数字范围按位与

将前缀保留就好

```java
class Solution {
    public int rangeBitwiseAnd(int left, int right) {
        int shift = 0;
        while(left < right){
            left >>= 1;
            right >>= 1;
            shift++;
        }
        return left << shift;
    }
}
```

![image-20211001103434632](https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20211001103437.png)

### 12. 数字的补数

```java
class Solution {
    public int findComplement(int num) {
        int mask = ~0;
        while((num & mask) > 0){
            mask <<= 1;
        }
        return ~mask ^ num;
    }
}
```

### 13. 数字转换为十六进制

```java
class Solution {
    public String toHex(int num) {
        if(num == 0){
            return "0";
        }
        char[] hexChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

        String res = "";
        while(num != 0){
            int index = num & 15;
            res = hexChars[index] + res;
            num >>>= 4;
        }
        return res;
    }
}
```

### 14. 颠倒二进制位

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for(int i = 0; i < 32; i++){
            res = (res << 1) | (n & 1);
            n >>>= 1;
        }
        return res;
    }
}
```

## 刷题第七天

### 1. 归并排序

```java
public class _912_sort_an_array {
    // 归并排序
    public int[] sortArray1(int[] nums) {
        mergeSort(nums, 0, nums.length - 1, new int[nums.length]);
        return nums;
    }

    private void mergeSort(int[] nums, int lo, int hi, int[] tmp) {
        if (lo >= hi) return;
        int mid = lo + (hi - lo) / 2;

        mergeSort(nums, lo, mid, tmp);
        mergeSort(nums, mid + 1, hi, tmp);

        merge(nums, lo, mid, hi, tmp);
    }

    private void merge(int[] nums, int lo, int mid, int hi, int[] tmp) {
        for (int i = lo; i <= hi; i++) {
            tmp[i] = nums[i];
        }
        int i = lo;
        int j = mid + 1;
        for (int k = lo; k <= hi; k++) {
            if (i == mid + 1) nums[k] = tmp[j++];
            else if (j == hi + 1) nums[k] = tmp[i++];
            else if (tmp[i] <= tmp[j]) nums[k] = tmp[i++];
            else nums[k] = tmp[j++];
        }
    }
}
```

### 2. 快速排序

```java
// 快排
public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

private void quickSort(int[] nums, int lo, int hi) {
    if (lo >= hi) return;
    int index = partition(nums, lo, hi);
    quickSort(nums, lo, index - 1);
    quickSort(nums, index + 1, hi);
}
// 二分切分
private int partition(int[] nums, int lo, int hi) {
    int i = new Random().nextInt(hi - lo + 1) + lo; // 随机选一个作为 pivot
    swap(nums, i, hi);
    int pivot = nums[hi];
    int less = lo, great = lo;
    for (; great <= hi - 1 ; great++) {
        if (nums[great] < pivot) {
            swap(nums, less, great);
            less++;
        }
    }
    swap(nums, less, hi);
    return less;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

// 三路快排
private void quickSort1(int[] nums, int lo, int hi) {
    if (lo >= hi) return;

    int j = new Random().nextInt(hi - lo + 1) + lo; // 随机选一个作为 pivot
    swap(nums, j, hi);
    int pivot = nums[hi];
    int less = lo, great = hi;
    int i = lo;
    while (i <= great) {
        if (nums[i] < pivot) {
            swap(nums, i, less);
            less++;
            i++;
        } else if (nums[i] > pivot) {
            swap(nums, i, great);
            great--;
        } else {
            i++;
        }
    }

    quickSort1(nums, lo, less - 1);
    quickSort1(nums, great + 1, hi);
}
```

### 3. 第二大数字

```java
//时间复杂度为O(n) 空间复杂度为O(1)
public class SecondMaxNumber{
    public int getSecondMax(int[] nums){
        int first = Integer.MIN_VALUE;
        int second = Integer.MIN_VALUE;
        for(int num : nums){
            if(num > first){
                second = first;
                first = num;
            }else if(num > second){
                second = num;
            }
        }
        return second;
    }
}
```

### 4. 三个数的最大乘积

找到数组中三个最大值和两个最小值

```java
class Solution {
    public int maximumProduct(int[] nums) {
        // 最小的和第二小的
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        // 最大的、第二大的和第三大的
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;

        for (int x : nums) {
            if (x < min1) {
                min2 = min1;
                min1 = x;
            } else if (x < min2) {
                min2 = x;
            }

            if (x > max1) {
                max3 = max2;
                max2 = max1;
                max1 = x;
            } else if (x > max2) {
                max3 = max2;
                max2 = x;
            } else if (x > max3) {
                max3 = x;
            }
        }

        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}
```

### 5. 合并两个有序数组

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n){
        int i = m -1;
        int j = n - 1;
        int k = m + n -1;
        while(j >= 0){
            if(i >= 0 && nums1[i] > nums2[j]){
                nums1[k] = nums1[i];
                i--;
            }else{
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
    }
}
```

### 6. 数组中的逆序对(剑指offer51)

````java
public class ReversePairs{
    public int reversePairs(int[] nums){
        if(nums == null || nums.length < 2){
            return 0;
        }
        int[] copy = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
            copy[i] = nums[i];
        }
        int[] temp = new int[nums.length];
        return reversePairs(copy, 0, nums.length - 1, temp);
    }
    private int reversePairs(int[] nums, int left, int right, int[] temp){
        if(left >= right){
            return 0;
        }
        int mid = left + (right - left) / 2;
        int leftReversePairs = reversePairs(nums,left, mid, temp);
        int rightReversePairs = reversePairs(nums,mid + 1,right,temp);
        
        int mergeReversePairs = mergeAndCountReversePairs(nums,mid + 1,right,temp);
        return leftReversePairs + rightReversePairs + mergeReversePairs;
    }
    private int mergeAndCountReversePairs(int[] data, int left, int mid, int right, int[] temp){
        for(int i = left; i<= right; i++){
            tmp[i] = data[i];
        }
        int count = 0;
        int i = left;
        int j = mid + 1;
        for(int k = left; k <= right; k++){
            if(i == mid + 1){// 左边没有元素，右边有元素
                data[k] = temp[j++];
            }else if(j == right+1){// 左边有元素，右边没有元素
                data[k] = temp[i++];
            }else{// tmp[i] > tmp[j]
                data[k] = data[j++];
                // 计算 temp[j] 的逆序对
                count += mid - i + 1;
            }     
        }
        return count;
    }
}
````

### 7. 计算右侧小于当前元素的个数

```java
class Solution {
    private int[] index;
    private int[] temp;
    private int[] tempIndex;
    private int[] ans;

    public List<Integer> countSmaller(int[] nums) {
        this.index = new int[nums.length];
        this.temp = new int[nums.length];
        this.tempIndex = new int[nums.length];
        this.ans = new int[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            index[i] = i;
        }
        int l = 0, r = nums.length - 1;
        mergeSort(nums, l, r);
        List<Integer> list = new ArrayList<Integer>();
        for (int num : ans) {
            list.add(num);
        }
        return list;
    }

    public void mergeSort(int[] a, int l, int r) {
        if (l >= r) {
            return;
        }
        int mid = (l + r) >> 1;
        mergeSort(a, l, mid);
        mergeSort(a, mid + 1, r);
        merge(a, l, mid, r);
    }

    public void merge(int[] a, int l, int mid, int r) {
        int i = l, j = mid + 1, p = l;
        while (i <= mid && j <= r) {
            if (a[i] <= a[j]) {
                temp[p] = a[i];
                tempIndex[p] = index[i];
                ans[index[i]] += (j - mid - 1);
                ++i;
                ++p;
            } else {
                temp[p] = a[j];
                tempIndex[p] = index[j];
                ++j;
                ++p;
            }
        }
        while (i <= mid)  {
            temp[p] = a[i];
            tempIndex[p] = index[i];
            ans[index[i]] += (j - mid - 1);
            ++i;
            ++p;
        }
        while (j <= r) {
            temp[p] = a[j];
            tempIndex[p] = index[j];
            ++j;
            ++p;
        }
        for (int k = l; k <= r; ++k) {
            index[k] = tempIndex[k];
            a[k] = temp[k];
        }
    }
}
```

### 8. 区间和的个数

```java
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        long s = 0;
        long[] sum = new long[nums.length + 1];
        for (int i = 0; i < nums.length; ++i) {
            s += nums[i];
            sum[i + 1] = s;
        }
        return countRangeSumRecursive(sum, lower, upper, 0, sum.length - 1);
    }

    public int countRangeSumRecursive(long[] sum, int lower, int upper, int left, int right) {
        if (left == right) {
            return 0;
        } else {
            int mid = (left + right) / 2;
            int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);
            int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);
            int ret = n1 + n2;

            // 首先统计下标对的数量
            int i = left;
            int l = mid + 1;
            int r = mid + 1;
            while (i <= mid) {
                while (l <= right && sum[l] - sum[i] < lower) {
                    l++;
                }
                while (r <= right && sum[r] - sum[i] <= upper) {
                    r++;
                }
                ret += r - l;
                i++;
            }

            // 随后合并两个排序数组
            long[] sorted = new long[right - left + 1];
            int p1 = left, p2 = mid + 1;
            int p = 0;
            while (p1 <= mid || p2 <= right) {
                if (p1 > mid) {
                    sorted[p++] = sum[p2++];
                } else if (p2 > right) {
                    sorted[p++] = sum[p1++];
                } else {
                    if (sum[p1] < sum[p2]) {
                        sorted[p++] = sum[p1++];
                    } else {
                        sorted[p++] = sum[p2++];
                    }
                }
            }
            for (int j = 0; j < sorted.length; j++) {
                sum[left + j] = sorted[j];
            }
            return ret;
        }
    }
}
```

### 9. 翻转对

```java
class Solution {
    public int reversePairs(int[] nums) {
        int[] tmp = new int[nums.length];
        return mergeSort(nums, 0, nums.length - 1, tmp);
    }
    private int mergeSort(int[] nums, int lo, int hi, int[] tmp){
        if(lo >= hi) return 0;
        int mid = lo + (hi - lo) / 2;

        int leftSumCount = mergeSort(nums, lo, mid, tmp);
        int rightSumCount = mergeSort(nums, mid + 1, hi, tmp);
        int count = 0;
        //计算当前翻转对的个数
        int i = lo;
        int j = mid + 1;
        while(i <= mid){
            while(j <= hi && (long)nums[i] > 2 * (long)nums[j]) j++;
            count += (j - mid - 1);
            i++;
        }
        merge(nums, lo, mid, hi, tmp);
        return leftSumCount + rightSumCount + count;
    }
    private void merge(int[] nums, int lo, int mid, int hi, int[] tmp){
        for(int i = lo; i <= hi; i++){
            tmp[i] = nums[i];
        }
        int i = lo; 
        int j = mid +1;
        for(int k = lo; k <= hi; k++){
            if(i == mid + 1) nums[k] = tmp[j++];
            else if(j == hi + 1) nums[k] = tmp[i++];
            else if(tmp[i] <= tmp[j]) nums[k] = tmp[i++];
            else nums[k] = tmp[j++];
        }
    }
}
```

### 10. Pow(x,n)

```java
class Solution {
    //快速幂 O(log n)
    public double myPow(double x, int n) {
        //使用 long 来存储 n，因为 -n 可能会越界
        long b = n;
        if(b < 0){
            x = 1 /x;
            b = -b;
        }
        return quickPow(x, b);
    }
    private double quickPow(double x, long n){
        if(n == 0) return 1.0;
        if(n == 1) return x;

        long mid = n /2;
        double y = quickPow(x, mid);
        return n % 2 == 0 ? y * y : x * y * y;
    }
}
```

### 11. 三路快排

```java
// 三路快排
private void quickSort1(int[] nums, int lo, int hi) {
    if (lo >= hi) return;

    int j = new Random().nextInt(hi - lo + 1) + lo; // 随机选一个作为 pivot
    swap(nums, j, hi);
    int pivot = nums[hi];
    int less = lo, great = hi;
    int i = lo;
    while (i <= great) {
        if (nums[i] < pivot) {
            swap(nums, i, less);
            less++;
            i++;
        } else if (nums[i] > pivot) {
            swap(nums, i, great);
            great--;
        } else {
            i++;
        }
    }

    quickSort1(nums, lo, less - 1);
    quickSort1(nums, great + 1, hi);
}
```

### 12. 颜色分类

```java
class Solution {
    public void sortColors(int[] nums) {
        //计数
        int[] count = new int[3];
        for(int num : nums){
            count[num]++;
        }
        //排序
        int k = 0;
        for(int i = 0; i <= 2; i++){
            int num = count[i];
            for(int j = 1; j <= num; j++){
                nums[k++] = i;
            }
        }
    }
}
```

### 13. 最大数

```java
class Solution {
    // 自定义排序
    public String largestNumber(int[] nums) {

        sort(nums, 0, nums.length - 1);

        StringBuilder sb = new StringBuilder();
        for (int str : nums) {
            sb.append(str);
        }
        if (sb.charAt(0) == '0') return "0";
        return sb.toString();
    }

    private void sort(int[] data, int lo, int hi) {
        if (lo >= hi) return;
        // 分区
        int pivot = data[hi];

        int less = lo;
        int great = hi;

        int i = lo;
        while (i <= great) {
            if ((data[i] + "" + pivot).compareTo(pivot + "" + data[i]) > 0) {
                swap(data, i, less);
                less++;
                i++;
            } else if ((data[i] + "" + pivot).compareTo(pivot + "" + data[i]) < 0) {
                swap(data, i, great);
                great--;
            } else {
                i++;
            }
        }

        sort(data, lo, less - 1);
        sort(data, great +1, hi);
    }

    private void swap(int[] strs, int i, int j) {
        int tmp = strs[i];
        strs[i] = strs[j];
        strs[j] = tmp;
    }
}

//用Java的库函数排序
import java.util.Arrays;
import java.util.Comparator;
class Solution {
    public String largestNumber(int [] nums){
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++){
            strs[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(strs, new LargestNumberComparator());
        if(strs[0].equals("0")){
            return "0";
        }
        String s = new String();
        for(String str : strs){
            s += str;
        }
        return s;
    }
    private class LargestNumberComparator implements Comparator<String>{
        @Override
        public int compare(String a, String b){
            String s1 = a + b;
            String s2 = b + a;
            return s2.compareTo(s1);
        }
    }
    
}
```

### 14. 合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return intervals;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[0] - b[0];
            }
        });
        List<int[]> res = new ArrayList<>();
        int[] cur = intervals[0];
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] > cur[1]){
                res.add(cur);
                cur = intervals[i];
            }else{
                cur[1]  = Math.max(cur[1], intervals[i][1]);
            }
        }
        res.add(cur);
        int[][] ans = new int[res.size()][2];
        for(int i = 0; i < res.size(); i++){
            ans[i] = res.get(i);
        }
        return ans;
    }
}
```

### 15. 插入区间

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> res = new ArrayList<>();
        int i = 0;//用于遍历所有区间
        //将区间结束小于新区间开始的区间放入到结果集里面
        while(i < intervals.length && intervals[i][1] < newInterval[0]){
            res.add(intervals[i]);
            i++;
        }
        //将区间开始小于等于新区间结束的区间和新区间合并
        while(i < intervals.length && intervals[i][0] <= newInterval[1]){
            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);
            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);
            i++;
        }
        //将合并的区间放入结果集
        res.add(newInterval);
        
        //将剩余的区间放入到结果集
        while(i < intervals.length){
            res.add(intervals[i]);
            i++;
        }
        return res.toArray(new int[res.size()][]);
    }
}
```

### 16. 按奇偶排序数组

```java
//法一：左右指针
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int[] ans = new int[nums.length];

        int left = 0;
        int right = nums.length - 1;

        for(int i = 0; i < nums.length; i++){
            if(nums[i] % 2 == 0){
                ans[left] = nums[i];
                left++;
            }else{
                ans[right] = nums[i];
                right--;
            }
        }
        return ans;
    }
}
//法二 排序 升序排序 比法一还差
 public int[] sortArrayByParity3(int[] A) {
     int n = A.length;
     Integer[] tmp = new Integer[n];
     for (int i = 0; i < n; i++) tmp[i] = A[i];
	//自定义排序 0-1 = -1 所以偶数在前
     Arrays.sort(tmp, (o1, o2) -> o1 % 2 - o2 % 2);

     for (int i = 0; i < n; i++) A[i] = tmp[i];

     return A;
 }
//法三 快排的二向切分 只是分区条件不一样 O(n) O(1)
// 快排分区的逻辑
public int[] sortArrayByParity4(int[] A) {
    int less = 0, great = 0;
    for (; great < A.length ; great++) {
        if (A[less] % 2 > A[great] % 2) {
            int tmp = A[less];
            A[less] = A[great];
            A[great] = tmp;
        }
        if (A[less] % 2 == 0) less++;
    }
    return A;
}
 // 快排分区的逻辑优化 对撞指针
public int[] sortArrayByParity(int[] A) {
    int less = 0, great = A.length - 1;
    while (less < great){
        if (A[less] % 2 > A[great] % 2) {
            int tmp = A[less];
            A[less] = A[great];
            A[great] = tmp;
        }
        if (A[less] % 2 == 0) less++;
        if (A[great] % 2 == 1) great--;
    }
    return A;
}
```

### 17. 按奇偶排序数组二

```java
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int n = nums.length;
        int i = 0;
        int j = 1;
        
        while(i < n){
            //如果当前偶数位置是奇数元素
            if(nums[i] % 2 == 1){
                //那么在奇数位置上找到一个偶数，与之交换
                while(nums[j] % 2 == 1) j += 2;
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
            i += 2;
        }
        return nums;
    }
}
```

### 18. 有多少小于当前数字的数字

```java
//排序后再统计
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int n = nums.length;
        // 维护元素值 -> 索引关系
        int[][] data = new int[n][2];
        for (int i = 0; i < n; i++) {
            data[i][0] = nums[i];
            // bug 修复：第二个值存储索引
            data[i][1] = i;
        }

        // 按照元素值升序排序
        Arrays.sort(data, (o1, o2) -> o1[0] - o2[0]);

        int[] ans = new int[n];
        int prev = -1;
        for (int i = 0; i < n; i++) {
            if (prev == -1 || data[i][0] != data[i - 1][0]) {
                prev = i;
            }
            ans[data[i][1]] = prev;
        }

        return ans;
    }
}
//级数 主要是因为数据量不大，最大值也就100，那就可以让数字充当下标
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int n = nums.length;
        int[] cnt = new int[101];

        for(int num : nums){
            cnt[num]++;
        }
        for(int i = 1;i < 101; i++){
            cnt[i] += cnt[i - 1];
        }
        int[] res = new int[n];
        for(int i = 0; i < n; i++){
            res[i] = nums[i] == 0 ? 0 : cnt[nums[i] - 1];
            
        }
        return res;
    }
}
```

### 19. 最大间距

```java
//桶排序
class Solution {
     // 桶排序
    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2)
            return 0;
        // 1. 找到最大最小值
        int min = nums[0];
        int max = nums[0];
        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        if (max == min) return 0;

        int gap = (int)Math.ceil((double)(max - min)/(nums.length - 1));

        // 2. 初始化桶数组
        int bucketNum = nums.length;
        int[][] buckets = new int[bucketNum][2];
        for (int i = 0; i < bucketNum; i++) {
            buckets[i][0] = Integer.MAX_VALUE;
            buckets[i][1] = Integer.MIN_VALUE;
        }

        // 3. 将所有元素添加到对应的桶中
        for (int num : nums) {
            // bucketId 计算逻辑如何理解，请参考 issue：https://gitee.com/douma_edu/douma_algo_training_camp/issues/I498BD
            int bucketId = (num - min) / gap;
            buckets[bucketId][0] = Math.min(buckets[bucketId][0], num);
            buckets[bucketId][1]= Math.max(buckets[bucketId][1], num);
        }

        // 4. 计算最大间隔
        int maxGap = 0;
        int prevBucketMax = min;
        for (int[] bucket : buckets) {
            if (bucket[0] == Integer.MAX_VALUE) continue;
            maxGap = Math.max(maxGap, bucket[0] - prevBucketMax);
            prevBucketMax = bucket[1];
        }

        return maxGap;
    }
}
//TODO 基数排序
```

## 刷题第八天

二分查找

## 刷题第九天

### 1. 宝石与石头

```java
// 哈希查找
class Solution {
    // 时间复杂度：O(n)
    // 空间复杂度：O(m)
    public int numJewelsInStones2(String jewels, String stones) {
        Set<Character> set = new HashSet<>();
        for (char c : jewels.toCharArray()) set.add(c);

        int ans = 0;
        for (char c : stones.toCharArray()) {
            if (set.contains(c)) ans++;
        }

        return ans;
    }

    // 哈希查找
    // 时间复杂度：O(n)
    // 空间复杂度：O(1)
    public int numJewelsInStones(String jewels, String stones) {
        int[] count = new int[58];
        for (char c : jewels.toCharArray()) count[c - 'A'] = 1;

        int ans = 0;
        for (char c : stones.toCharArray()) {
            if (count[c - 'A'] == 1) ans++;
        }

        return ans;
    }
}
```

### 2. 公平的糖果棒交换

### 3. 最长连续序列

### 4. 只出现一次的数字

### 5. 找不同

### 6. 砖墙

### 7. 同构字符串

### 8. 单词规律

### 9. 有效的字母异位词

```java
public boolean isAnagram2(String s, String t) {
    if (s.length() != t.length()) return false;
    // 1. 统计字符串 s 中每个字符出现的次数
    Map<Character, Integer> map = new HashMap<>();
    for (char c : s.toCharArray()) {
        if (map.containsKey(c)) {
            map.put(c, map.get(c) + 1);
        } else {
            map.put(c, 1);
        }
    }

    // 2. 减去字符串 t 中字符出现的次数，如果出现的次数出现小于 0 的话，则返回 false
    for (char c : t.toCharArray()) {
        map.put(c, map.getOrDefault(c, 0) - 1);
        if (map.get(c) < 0) return false;
    }
    return true;
}
```

### 10. 字母异位词分组

### 11. 和为K的子数组

### 12. 缺失的第一个正数

### 13. 数组的相对排序

## 刷题第十天

### 1. 有效的括号

### 2. 简化路径

### 3. 字符串解码

### 4. 基本计算器

### 5. 基本计算器二

### 6. 验证栈序列

### 7. 单调栈

### 8. 每日温度

### 9. 接雨水

### 10. 柱状图中最大的矩形

### 11. 最大矩形

### 12. 拼接最大数

### 13. 132模式

### 14. 翻转字符串里的单词

## 刷题第十一天

## 刷题第十二天

### 1. 子数组最大平均数I

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        int n = nums.length;
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }
        int maxSum = sum;
        for (int i = k; i < n; i++) {
            sum = sum - nums[i - k] + nums[i];
            maxSum = Math.max(maxSum, sum);
        }
        return 1.0 * maxSum / k;
    }
}
```

## 刷题第十六天

### 1. 前序遍历

```java
// 递归解法
public List<Integer> preorderTraversal(TreeNode root) {
    ArrayList<Integer> res = new ArrayList<>();
    if (root ==null) return res;
    preOrder(root, res);
    return res;
}

private void preOrder(TreeNode node, List<Integer> res) {
    if (node == null) return;
    // 处理当前遍历的节点
    res.add(node.val);
    preOrder(node.left, res);
    preOrder(node.right, res);
}
```

### 2. 中序遍历

```java
// 递归解法
public List<Integer> inOrderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root ==null) return res;
    inOrder(root, res);
    return res;
}

private void inOrder(TreeNode node, List<Integer> res) {
    if (node == null) return;
    inOrder(node.left, res);
    res.add(node.val);
    inOrder(node.right, res);
}
```

### 3. 后序遍历

```Java
   // 递归解法
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root ==null) return res;
    postorder(root, res);
    return res;
}
private void postorder(TreeNode node, List<Integer> res) {
    if (node == null) return;
    postorder(node.left, res);
    postorder(node.right, res);
    res.add(node.val);
}
```

### 4. 前序遍历实现层序遍历

````java
// 前序遍历(递归)实现层序遍历
public List<List<Integer>> levelOrder(TreeNode root){
    List<List<Integer>> res = new ArrayList<>();
    preOrder(root, 0, res);
    return res;
}
private void preOrder(TreeNode node, int currLevel, List<List<Integer>> res){
    if(node == null) return;
    // 处理当前遍历的节点
    if(res.size() == currLevel){
        List<Integer> levelNodes = new ArrayList<>();
        levelNodes.add(node.val);
        res.add(levelNodes);
    }else{
        res.get(currLevel).add(node.val);
    }
    preOrder(node.left, currLevel + 1, res);
    preOrder(node.right, currLevel + 1, res);
}
````

