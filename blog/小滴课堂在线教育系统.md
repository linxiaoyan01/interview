---
title: 小滴课堂在线教育系统
categories: Java项目实战
tags: [小滴课堂]
---

# 小滴课堂在线教育系统

## 在线教育的核心模块

- 注册
- 登录
- 轮播图
- 视频列表
- 视频详情
- 下单购买
- 我的订单
- 个人中心

项目技术栈

- 后端 SpringBoot + Spring +Mybatis +JWT +MySQL +Gauva +Jmeter5.X + IDEA
- 前端 Vue +VueCLi + Axios +Vuex + CubeUI + VS CODE
- 部署 阿里云CentOS7 + Nginx + 域名解析

## 在线教育的核心库表结构

> - video_banner
> - video
> - chapter
> - episode
> - video_order
> - user

- MySQL测试数据导入
- MySQL客户端软件
  - 苹果系统：sequel pro
  - Windows：navicat

- 本地安装是可以直接访问

- 虚拟机或者云服务器安装，测试的话一定要开启MySQL远程访问和防火墙开放对应的端口（搜索博文）
- 没有一成不变的架构，没有通用的设计方案，一定跟业务结合

- 导入课程MySQL, 本地安装MySQL务必使用5.7版本

 ## SpringBoot2.X 后端项目框架搭建

在线创建

- https://start.spring.io/

添加依赖

- springboot核心包

  ```xml
   <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
          <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
          </exclusion>
        </exclusions>
      </dependency>
  ```

- mybaits依赖

  ```xml
  <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.1.2</version>
  </dependency>
  ```

- mysql驱动 (注意需要去掉runtime，否则报错)

  ```xml
  <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
  </dependency>
  ```

- 通用工具包

  ```xml
  <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.9</version>
  </dependency>
  ```

- 跨域身份验证解决方案 Json web token包

  ```xml
  <!-- JWT相关 -->
  <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
        <version>0.7.0</version>
  </dependency>
  ```

- 高性能缓存组件

  ```xml
  <!--guava依赖包-->
  <dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>19.0</version>
  </dependency>
  ```

## 创建相关的包和项目用的实体类

项目基本包结构

- domain实体类创建完成
- controller-service-mapper
- utils-config-interceptor

# 小滴课堂项目实战之打通Mybatis连接MySQL开发视频列表

## 小滴课堂实战之Mybatis打通MySQL数据库

添加数据库配置

```properties
server.port=8081

#==============================数据库相关配置========================================
spring.datasource.driver-class-name =com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/online_xdclass?useUnicode=true&characterEncoding=utf-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=xdclass.net
#使用阿里巴巴druid数据源，默认使用自带的
#spring.datasource.type =com.alibaba.druid.pool.DruidDataSource
#开启控制台打印sql
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# mybatis 下划线转驼峰配置,两者都可以
#mybatis.configuration.mapUnderscoreToCamelCase=true
mybatis.configuration.map-underscore-to-camel-case=true
#配置扫描
mybatis.mapper-locations=classpath:mapper/*.xml
#配置xml的结果别名
mybatis.type-aliases-package=net.xdclass.online_xdclass.domain
```

- 创建Video相关类

- 创建VideoMapper.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
  <mapper namespace="net.xdclass.online_xdclass.mapper.VideoMapper">
  
  </mapper>
  ```

- 配置扫描mapper路径

  ```java
  @SpringBootApplication
  @MapperScan("net.xdclass.online_xdclass.mapper")
  public class OnlineXdclassApplication {
  
    public static void main(String[] args) {
      SpringApplication.run(OnlineXdclassApplication.class, args);
    }
  }
  ```

## 小滴课堂实战之视频列表接口开发+API权限路径规划

**开发视频列表JSON接口**

- postman调试接口
  - 浏览器如果要支持json格化，需要安装谷歌插件，但是网络问题直接安装不了，推荐使用插件
- 开发视频列表接口
- 开发jsondata工具类
- 规划api权限路径
  - /api/v1/pub/AA/BB 这个是不需要登录
  - /api/v1/pri/AA/BB 这个是需要登录

## 小滴课堂实战之实现IDEA项目热部署

dev-tool不好使

我用了`JRebel`

## 小滴课堂实战之首页banner轮播图和视频详情接口开发

**首页banner轮播图接口开发**

开发轮播列表接口

```xml
<select id="listVideoBanner" resultType="VideoBanner">
        select  * from video_banner order by weight asc
</select>
```

## 小滴课堂实战之视频详情接口开发-三表关联查询映射

**视频详情接口，多表关联开发**

- 修改Video-Chapter POJO类, 增加属性（不使用DTO）
- 定义ResultMap
- 调试接口数据

```xml
<resultMap id="VideoDetailResultMap" type="Video">
        <id column="id" jdbcType="INTEGER" property="id"/>

        <result column="title" jdbcType="VARCHAR" property="title"/>
        <result column="summary" jdbcType="VARCHAR" property="summary"/>
        <result column="cover_img" jdbcType="VARCHAR" property="coverImg"/>
        <result column="price" jdbcType="INTEGER" property="price"/>
        <result column="point" jdbcType="DOUBLE" property="point"/>
        <result column="create_time" jdbcType="TIMESTAMP" property="createTime"/>

        <collection property="chapterList" ofType="Chapter">
            <id column="chapter_id" jdbcType="INTEGER" property="id"/>
            <result column="chapter_title" jdbcType="VARCHAR" property="title"/>
            <result column="ordered" jdbcType="INTEGER" property="ordered"/>
            <result column="chapter_create_time" jdbcType="TIMESTAMP" property="createTime"/>

            <collection property="episodeList" ofType="Episode">
                <id column="episode_id" jdbcType="INTEGER" property="id"/>
                <result column="num" jdbcType="INTEGER" property="num"/>
                <result column="episode_title" jdbcType="VARCHAR" property="title"/>
                <result column="episode_ordered" jdbcType="INTEGER" property="ordered"/>
                <result column="play_url" jdbcType="VARCHAR" property="playUrl"/>
                <result column="free" jdbcType="INTEGER" property="free"/>
                <result column="episode_create_time" jdbcType="TIMESTAMP" property="createTime"/>
            </collection>
        </collection>
</resultMap>
<select id="findDetailById" resultMap="VideoDetailResultMap">

        select
        v.id, v.title,v.summary,v.cover_img,v.price,v.point,v.create_time,
        c.id as chapter_id, c.title as chapter_title, c.ordered,c.create_time as chapter_create_time,
        e.id as episode_id, e.num, e.title as episode_title,e.ordered as episode_ordered,e.play_url,e.free,e.create_time as episode_create_time

        from video v

        left join chapter c on v.id=c.video_id

        left join episode e on c.id=e.chapter_id

        where v.id = #{video_id}
        order by c.ordered,e.num asc

</select>
```

## 小滴课堂实战之自定义异常开发和配置

**开发自定义异常和配置**

自定义异常 继承 RuntimeException

```java
/**
 * 小滴课堂
 * 自定义异常类
 */
public class XDException extends RuntimeException{

    private Integer code;

    private String msg;

    public XDException(Integer code, String msg){
        this.code = code;
        this.msg = msg;
    }
    public Integer getCode() {
        return code;
    }
    public void setCode(Integer code) {
        this.code = code;
    }
    public String getMsg() {
        return msg;
    }
    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```

开发异常处理器ExceptionHandler

```java
/**
 * 异常处理类
 */
@ControllerAdvice
public class CustomExceptionHandler {

    private final static Logger logger = LoggerFactory.getLogger(CustomExceptionHandler.class);

    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public JsonData handle(Exception e){

        logger.error("[ 系统异常 ]{}",e);
        if( e instanceof XDException ){
            XDException xdException = (XDException) e;
            return JsonData.buildError(xdException.getCode(),xdException.getMsg());
        }else {
            return JsonData.buildError("全局异常，未知错误");
        }
    }
}
```

# 小滴课堂项目实战之用户注册登录模块和JWT登录解决方案

## 小滴课堂实战之用户注册功能开发和MD5加密工具类封装

**用户注册功能接口开发**

注册接口开发

```sql
//增加唯一索引
CREATE TABLE `user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL COMMENT '昵称',
  `pwd` varchar(124) DEFAULT NULL COMMENT '密码',
  `head_img` varchar(524) DEFAULT NULL COMMENT '头像',
  `phone` varchar(64) DEFAULT '' COMMENT '手机号',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `phone` (`phone`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
```

MD5加密工具类封装（不用死记，不常用的方法，直接拷贝使用就行，基本是写一次，其他项目直接拷贝）

```java
public static String MD5(String data)  {
        try {
            java.security.MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] array = md.digest(data.getBytes("UTF-8"));
            StringBuilder sb = new StringBuilder();
            for (byte item : array) {
                sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));
            }
            return sb.toString().toUpperCase();
        } catch (Exception exception) {
        }
        return null;
}
```

随机头像生成

```java
private static final String [] headImg = {
            "https://xd-video-pc-img.oss-cn-beijing.aliyuncs.com/xdclass_pro/default/head_img/12.jpeg",
            "https://xd-video-pc-img.oss-cn-beijing.aliyuncs.com/xdclass_pro/default/head_img/11.jpeg",
            "https://xd-video-pc-img.oss-cn-beijing.aliyuncs.com/xdclass_pro/default/head_img/13.jpeg",
            "https://xd-video-pc-img.oss-cn-beijing.aliyuncs.com/xdclass_pro/default/head_img/14.jpeg",
            "https://xd-video-pc-img.oss-cn-beijing.aliyuncs.com/xdclass_pro/default/head_img/15.jpeg"
    };
```

## 常见的互联网项目中 单机和分布式应用的登录校验解决方案

**讲解单机和分布式应用下登录校验，session共享，分布式缓存使用**

单机tomcat应用登录检验

- sesssion保存在浏览器和应用服务器会话之间
- 用户登录成功，服务端会保存一个session，当然客户端有一个sessionId
- 客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId

分布式应用中session共享

- 真实的应用不可能单节点部署，所以就有个多节点登录session共享的问题需要解决
- tomcat支持session共享，但是有广播风暴；用户量大的时候，占用资源就严重，不推荐
- 使用redis存储token:
  - 服务端使用UUID生成随机64位或者128位token，放入redis中，然后返回给客户端并存储在cookie中
  - 用户每次访问都携带此token，服务端去redis中校验是否有此用户即可

## 分布式应用下登录检验解决方案 JWT讲解

什么是JWT

JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。

- JWT 是一个开放标准，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名
- **简单来说: 就是通过一定规范来生成token，然后可以通过解密算法逆向解密token，这样就可以获取用户信息**

```
            {
              id:888,
              name:'小D',
              expire:10000
            }
            
            funtion 加密(object, appsecret){
            xxxx
            return base64( token);
            }

            function 解密(token ,appsecret){

            xxxx
            //成功返回true,失败返回false
            }
```

- 优点
  - 生产的token可以包含基本信息，比如id、用户昵称、头像等信息，避免再次查库
  - 存储在客户端，不占用服务端的内存资源
- 缺点
  - token是经过base64编码，所以可以解码，因此token加密前的对象不应该包含敏感信息，如用户权限，密码等
  - 如果没有服务端存储，则不能做登录失效处理，除非服务端改秘钥

 JWT格式组成 头部、负载、签名

- header+payload+signature
  - 头部：主要是描述签名算法
  - 负载：主要描述是加密对象的信息，如用户的id等，也可以加些规范里面的东西，如iss签发者，exp 过期时间，sub 面向的用户
  - 签名：主要是把前面两部分进行加密，防止别人拿到token进行base解密后篡改token

关于jwt客户端存储

- 可以存储在cookie，localstorage和sessionStorage里面

## 登录校验Json Web Token实战之封装通用方法

**引入相关依赖并开发JWT工具类, 开发生产token和校验token的办法**

加入相关依赖

```xml
 <!-- JWT相关 -->
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt</artifactId>
      <version>0.7.0</version>
    </dependency>
```

封装生产token方法

```java
/**
     * 根据用户信息，生成令牌
     * @param user
     * @return
     */
    public static String geneJsonWebToken(User user){

        String token = Jwts.builder().setSubject(SUBJECT)
                .claim("head_img",user.getHeadImg())
                .claim("id",user.getId())
                .claim("name",user.getName())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))
                .signWith(SignatureAlgorithm.HS256,SECRET).compact();

        token = TOKEN_PREFIX + token;


        return token;
    }
```

封装校验token方法

```java
/**
     * 校验token的方法
     * @param token
     * @return
     */
    public static Claims checkJWT(String token){

        try{
            final  Claims claims = Jwts.parser().setSigningKey(SECRET)
                    .parseClaimsJws(token.replace(TOKEN_PREFIX,"")).getBody();
            return claims;
        }catch (Exception e){
            return null;
        }
    }
```

## 小滴课堂实战之登录模块开发整合Json Web Token

**开发登录模块功能，并整合JSON Web Token**

- 开发登录功能

- 修改domain 为model层

  - 增加entity、request包

  - 记得改application.properties配置文件扫描路径!!!!

    ```properties
    server.port=8089
    
    #==============================数据库相关配置========================================
    spring.datasource.driver-class-name =com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql://127.0.0.1:33061/online_xdclass?useUnicode=true&characterEncoding=utf-8&useSSL=false
    spring.datasource.username=root
    spring.datasource.password=xdclass.net
    #使用阿里巴巴druid数据源，默认使用自带的
    #spring.datasource.type =com.alibaba.druid.pool.DruidDataSource
    #开启控制台打印sql
    mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
    
    # mybatis 下划线转驼峰配置,两者都可以
    #mybatis.configuration.mapUnderscoreToCamelCase=true
    mybatis.configuration.map-underscore-to-camel-case=true
    #配置扫描
    mybatis.mapper-locations=classpath:mapper/*.xml
    #配置xml的结果别名
    mybatis.type-aliases-package=net.xdclass.online_xdclass.model.entity
    ```

- 整合JWT工具类

# 小滴课堂项目实战之登录拦截器开发和订单模块开发

## 小滴课堂实战之用户登录校验拦截器开发

开发loginInterceptor

- 登录校验成功放行

  ```java
   /**
       * 进入到controller之前的方法
       * @param request
       * @param response
       * @param handler
       * @return
       * @throws Exception
       */
  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
          try {
              String accesToken = request.getHeader("token");
              if (accesToken == null) {
                  accesToken = request.getParameter("token");
              }
              if (StringUtils.isNotBlank(accesToken)) {
                  Claims claims = JWTUtils.checkJWT(accesToken);
                  if (claims == null) {
                      //告诉登录过期，重新登录
                      sendJsonMessage(response, JsonData.buildError("登录过期，重新登录"));
                      return false;
                  }
                  Integer id = (Integer) claims.get("id");
                  String name = (String) claims.get("name");
                  request.setAttribute("user_id", id);
                  request.setAttribute("name", name);
                  return true;
              }
          }catch (Exception e){}
          sendJsonMessage(response, JsonData.buildError("登录过期，重新登录"));
          return false;
  }
  ```

## 小滴课堂实战之loginInterceptor注册和放行路径

**loginInterceptor 拦截器注册和路径校验配置**

- 继承 WebMvcConfigurer
- 配置拦截路径和放行路径

```java
/**
 * 拦截器配置
 *
 * 不用权限可以访问url    /api/v1/pub/
 * 要登录可以访问url    /api/v1/pri/
 */
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

    @Bean
    LoginInterceptor loginInterceptor(){
        return new LoginInterceptor();
    }
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //拦截全部
        registry.addInterceptor(loginInterceptor()).addPathPatterns("/api/v1/pri/*/*/**")
                //不拦截哪些路径   斜杠一定要加
                .excludePathPatterns("/api/v1/pri/user/login","/api/v1/pri/user/register");

        WebMvcConfigurer.super.addInterceptors(registry);

    }
}
```

## 小滴课堂实战之个人信息查询接口开发

**根据token查询个人信息接口开发**

- 通过token解密查询数据库获取个人信息

```java
@RestController
@RequestMapping("api/v1/pri/user")
public class UserController {
    @Autowired
    private UserService userService;
    /**
     * 根据用户id查询用户信息
     * @param request
     * @return
     */
    @GetMapping("find_by_token")
    public JsonData findUserInfoByToken(HttpServletRequest request){

        Integer userId = (Integer) request.getAttribute("user_id");
        if(userId == null){
            return JsonData.buildError("查询失败");
        }
        User user =  userService.findByUserId(userId);
        return JsonData.buildSuccess(user);

    }
}
```

```java
public interface UserService {
    User findByUserId(Integer userId);
}
```

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public User findByUserId(Integer userId) {

    User user = userMapper.findByUserId(userId);
    return user;
}
```

```java
public interface UserMapper {
    User findByUserId(@Param("user_id") Integer userId);
}
```

```xml
<select id="findByUserId" resultType="User">

    select  * from user where id=#{user_id}

</select>
```

## 小滴课堂实战之VideoOrder下单模块开发

VideoOrderRequest类

```java
package net.xdclass.online_xdclass.model.request;
import com.fasterxml.jackson.annotation.JsonProperty;
/**
 * @author Yuery
 * @date 2021/4/15/0015 - 18:01
 */
public class VideoOrderRequest {

    @JsonProperty("video_id")
    private int videoId;

    public int getVideoId(){
        return videoId;
    }
    public void setVideoId(int videoId){
        this.videoId = videoId;
    }
}
```

```java
package net.xdclass.online_xdclass.controller;

import net.xdclass.online_xdclass.model.entity.VideoOrder;
import net.xdclass.online_xdclass.model.request.VideoOrderRequest;
import net.xdclass.online_xdclass.service.VideoOrderService;
import net.xdclass.online_xdclass.utils.JsonData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.List;

@RestController
@RequestMapping("/api/v1/pri/order")
public class VideoOrderController {

    @Autowired
    private VideoOrderService videoOrderService;
    /**
     * 下单接口
     * @return
     */
    @RequestMapping("save")
    public JsonData saveOrder(@RequestBody VideoOrderRequest videoOrderRequest, HttpServletRequest request){

        Integer userId = (Integer) request.getAttribute("user_id");
        int rows = videoOrderService.save(userId, videoOrderRequest.getVideoId());

        return rows == 0 ? JsonData.buildError("下单失败"):JsonData.buildSuccess();
    }

    /**
     * 订单列表
     * @param request
     * @return
     */
    @GetMapping("list")
    public JsonData listOrder(HttpServletRequest request){
        Integer userId = (Integer) request.getAttribute("user_id");

        List<VideoOrder> videoOrderList = videoOrderService.listOrderByUserId(userId);

        return JsonData.buildSuccess(videoOrderList);

    }
}
```

```java
package net.xdclass.online_xdclass.service;

import net.xdclass.online_xdclass.model.entity.VideoOrder;

import java.util.List;
public interface VideoOrderService {

    int save(int userId, int videoId);

    List<VideoOrder> listOrderByUserId(Integer userId);
}
```

```java
package net.xdclass.online_xdclass.service.impl;

import net.xdclass.online_xdclass.exception.XDException;
import net.xdclass.online_xdclass.mapper.*;
import net.xdclass.online_xdclass.model.entity.Episode;
import net.xdclass.online_xdclass.model.entity.PlayRecord;
import net.xdclass.online_xdclass.model.entity.Video;
import net.xdclass.online_xdclass.model.entity.VideoOrder;
import net.xdclass.online_xdclass.model.request.VideoOrderRequest;
import net.xdclass.online_xdclass.service.VideoOrderService;
import net.xdclass.online_xdclass.service.VideoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.List;
import java.util.UUID;


@Service
@Transactional
public class VideoOrderServiceImpl implements VideoOrderService {
    @Autowired
    private VideoOrderMapper videoOrderMapper;
    @Autowired
    private VideoMapper videoMapper;
    @Autowired
    private EpisodeMapper episodeMapper;
    @Autowired
    private PlayRecordMapper playRecordMapper;
    /**
     * 下单操作
     * 未来版本：优惠券抵扣，风控用户检查，生成订单基础信息，生成支付信息
     * @param userId
     * @param videoId
     * @return
     */
    @Override
    @Transactional
    public int save(int userId, int videoId) {

        //判断是否已经购买
        VideoOrder videoOrder = videoOrderMapper.findByUserIdAndVideoIdAndState(userId,videoId,1);

        if(videoOrder!=null){return  0;}

        Video video = videoMapper.findById(videoId);

        VideoOrder newVideoOrder = new VideoOrder();
        newVideoOrder.setCreateTime(new Date());
        newVideoOrder.setOutTradeNo(UUID.randomUUID().toString());
        newVideoOrder.setState(1);
        newVideoOrder.setTotalFee(video.getPrice());
        newVideoOrder.setUserId(userId);

        newVideoOrder.setVideoId(videoId);
        newVideoOrder.setVideoImg(video.getCoverImg());
        newVideoOrder.setVideoTitle(video.getTitle());
        int rows = videoOrderMapper.saveOrder(newVideoOrder);
    @Override
    public List<VideoOrder> listOrderByUserId(Integer userId) {
        return videoOrderMapper.listOrderByUserId(userId);
    }
}
```

```java
package net.xdclass.online_xdclass.service;

import net.xdclass.online_xdclass.model.entity.VideoOrder;

import java.util.List;
public interface VideoOrderService {

    int save(int userId, int videoId);

    List<VideoOrder> listOrderByUserId(Integer userId);
}
```

```java
package net.xdclass.online_xdclass.mapper;

import net.xdclass.online_xdclass.model.entity.VideoOrder;
import net.xdclass.online_xdclass.service.VideoOrderService;
import org.apache.ibatis.annotations.Param;

import javax.annotation.security.PermitAll;
import java.util.List;
public interface VideoOrderMapper {

    VideoOrder findByUserIdAndVideoIdAndState(@Param("user_id") int userId, @Param("video_id") int videoId, @Param("state") int state);

    /**
     * 下单
     * @param videoOrder
     * @return
     */
    int saveOrder(VideoOrder videoOrder);

    /**
     * 视频订单列表
     * @param userId
     * @return
     */
    List<VideoOrder> listOrderByUserId(@Param("user_id") Integer userId);
}
```

```xml
<insert id="saveOrder" useGeneratedKeys="true" keyColumn="id" keyProperty="id">
    INSERT INTO `video_order` (`out_trade_no`, `state`, `create_time`, `total_fee`, `video_id`,
    `video_title`, `video_img`, `user_id`)
    VALUES
    (#{outTradeNo,jdbcType=VARCHAR},#{state,jdbcType=INTEGER},#{createTime,jdbcType=TIMESTAMP},#{totalFee,jdbcType=INTEGER},
    #{videoId,jdbcType=INTEGER},#{videoTitle,jdbcType=VARCHAR},#{videoImg,jdbcType=VARCHAR},#{userId,jdbcType=INTEGER});

</insert>
```

## 小滴课堂实战之播放记录表设计和模块开发

play_record表设计

```sql
CREATE TABLE `play_record` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `video_id` int(11) DEFAULT NULL,
  `current_num` int(11) DEFAULT NULL COMMENT '当前播放第几集',
  `episode_id` int(11) DEFAULT NULL COMMENT '当前播放第几集视频id',
  `create_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;
```

```java
public class PlayRecord {


    private Integer id;

    @JsonProperty("user_id")
    private Integer userId;

    @JsonProperty("video_id")
    private Integer videoId;

    @JsonProperty("current_num")
    private Integer currentNum;

    @JsonProperty("episode_id")
    private Integer episodeId;

    @JsonProperty("create_time")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
    private Date createTime;
    //省略set get方法
}
```

```java
package net.xdclass.online_xdclass.service.impl;

import net.xdclass.online_xdclass.exception.XDException;
import net.xdclass.online_xdclass.mapper.*;
import net.xdclass.online_xdclass.model.entity.Episode;
import net.xdclass.online_xdclass.model.entity.PlayRecord;
import net.xdclass.online_xdclass.model.entity.Video;
import net.xdclass.online_xdclass.model.entity.VideoOrder;
import net.xdclass.online_xdclass.model.request.VideoOrderRequest;
import net.xdclass.online_xdclass.service.VideoOrderService;
import net.xdclass.online_xdclass.service.VideoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class VideoOrderServiceImpl implements VideoOrderService {

    @Autowired
    private VideoOrderMapper videoOrderMapper;
    @Autowired
    private VideoMapper videoMapper;
    @Autowired
    private EpisodeMapper episodeMapper;
    @Autowired
    private PlayRecordMapper playRecordMapper;
    /**
     * 下单操作
     * 未来版本：优惠券抵扣，风控用户检查，生成订单基础信息，生成支付信息
     * @param userId
     * @param videoId
     * @return
     */
    @Override
    @Transactional
    public int save(int userId, int videoId) {

        //判断是否已经购买
        VideoOrder videoOrder = videoOrderMapper.findByUserIdAndVideoIdAndState(userId,videoId,1);

        if(videoOrder!=null){return  0;}

        Video video = videoMapper.findById(videoId);

        VideoOrder newVideoOrder = new VideoOrder();
        newVideoOrder.setCreateTime(new Date());
        newVideoOrder.setOutTradeNo(UUID.randomUUID().toString());
        newVideoOrder.setState(1);
        newVideoOrder.setTotalFee(video.getPrice());
        newVideoOrder.setUserId(userId);

        newVideoOrder.setVideoId(videoId);
        newVideoOrder.setVideoImg(video.getCoverImg());
        newVideoOrder.setVideoTitle(video.getTitle());

        int rows = videoOrderMapper.saveOrder(newVideoOrder);

        //生成播放记录
        if(rows == 1){
            Episode episode = episodeMapper.findFirstEpisodeByVideoId(videoId);
            if(episode == null){
                throw  new XDException(-1,"视频没有集信息，请运营人员检查");
            }
            PlayRecord playRecord = new PlayRecord();
            playRecord.setCreateTime(new Date());
            playRecord.setEpisodeId(episode.getId());
            playRecord.setCurrentNum(episode.getNum());
            playRecord.setUserId(userId);
            playRecord.setVideoId(videoId);
            playRecordMapper.saveRecord(playRecord);
        }
        return rows;
    }
    @Override
    public List<VideoOrder> listOrderByUserId(Integer userId) {
        return videoOrderMapper.listOrderByUserId(userId);
    }
}
```

```java
package net.xdclass.online_xdclass.mapper;
import net.xdclass.online_xdclass.model.entity.PlayRecord;
public interface PlayRecordMapper {
    int saveRecord(PlayRecord playRecord);
}
```

```xml
<insert id="saveRecord" useGeneratedKeys="true" keyProperty="id" keyColumn="id">

    INSERT INTO `play_record` ( `user_id`, `video_id`, `current_num`, `episode_id`, `create_time`)
    VALUES (#{userId},#{videoId},#{currentNum},#{episodeId},#{createTime});

</insert>
```

## 小滴课堂实战之订单和播放记录事务控制

开启事务控制

- 启动类 @EnableTransactionManagement
- 业务类，或者业务方法 @Transactional
- 默认事务的隔离级别和传播属性

# 性能优化实战之协议优化和引入Guava缓存

## 小滴课堂实战之接口协议调整和日期格式

- 统一输出协议，驼峰转下划线

- 格式化日期

  ```java
  @JsonProperty("create_time")
  @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
  private Date createTime;
  ```

## 高并发项目必备利器之分布式缓存和本地缓存

## 分布式缓存和本地缓存知识

- 什么是缓存
  - 程序经常要调用的对象存在内存中,方便其使用时可以快速调用,不必去数据库或者其他持久化设备中查询，主要就是提高性能
  - DNS缓存、前端缓存、代理服务器缓存Nginx、应用程序缓存（本地缓存、分布式缓存）、数据库缓存

- 分布式缓存
  - 与应用分离的缓存组件或服务，与本地应用隔离一个独立的应用，多个应用可直接的共享缓存
  - 常见的分布式缓存 Redis、Memcached等

- 本地缓存
  - 和业务程序一起的缓存，例如mybatis的一级或者二级缓存，本地缓存自然是最快的，但是不能在多个节点共享
  - 常见的本地缓存：myabtis一级缓存、mybatis二级缓存；框架本身的缓存； redis本地单机服务；ehchche；guava cache、Caffeine等

- 选择本地缓存和分布式缓存
  - 和业务数据结合去选择
  - 高并发项目里面一般都是有本地缓存和分布式缓存共同存在的

## 谷歌开源缓存框架Guava Cache讲解和封装缓存组件

Guava Cache

- github地址：https://github.com/google/guava/wiki/CachesExplained
- 全内存的本地缓存实现
- 高性能且功能丰富
- 线程安全，操作简单 (底层实现机制类似ConcurrentMap)

添加依赖

```xml
<!--guava依赖包-->
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>19.0</version>
    </dependency>
```

封装api

```java
package net.xdclass.online_xdclass.utils;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.springframework.stereotype.Component;
import java.util.concurrent.TimeUnit;
@Component
public class BaseCache {
    private Cache<String,Object> tenMinuteCache = CacheBuilder.newBuilder()

            //设置缓存初始大小，应该合理设置，后续会扩容
            .initialCapacity(10)
            //最大值
            .maximumSize(100)
            //并发数设置
            .concurrencyLevel(5)

            //缓存过期时间，写入后10分钟过期
            .expireAfterWrite(600,TimeUnit.SECONDS)

            //统计缓存命中率
            .recordStats()

            .build();
    private Cache<String,Object> oneHourCache = CacheBuilder.newBuilder()
            //设置缓存初始大小，应该合理设置，后续会扩容
            .initialCapacity(30)
            //最大值
            .maximumSize(100)
            //并发数设置
            .concurrencyLevel(5)

            //缓存过期时间，写入后1小时 过期
            .expireAfterWrite(3600,TimeUnit.SECONDS)

            //统计缓存命中率
            .recordStats()

            .build();

    public Cache<String, Object> getOneHourCache() {
        return oneHourCache;
    }
    public void setOneHourCache(Cache<String, Object> oneHourCache) {
        this.oneHourCache = oneHourCache;
    }
    public Cache<String, Object> getTenMinuteCache() {
        return tenMinuteCache;
    }
    public void setTenMinuteCache(Cache<String, Object> tenMinuteCache) {
        this.tenMinuteCache = tenMinuteCache;
    }
}
```

## 小滴课堂实战之引入本地缓存

**轮播图接口加入缓存**

**视频列表引入本地缓存**

**视频详情加入本地缓存**

```java
package net.xdclass.online_xdclass.config;
/**
 * 缓存key管理类
 */
public class CacheKeyManager {
    /**
     * 首页轮播图缓存key
     */
    public static final String INDEX_BANNER_KEY = "index:banner:list"; 
    /**
     * 首页视频列表缓存key
     */
    public static final String INDEX_VIDEL_LIST = "index:video:list"; 
    /**
     * 视频详情缓存key, %s是视频id
     */
    public static final String VIDEO_DETAIL = "video:detail:%s";
}
```

```java
package net.xdclass.online_xdclass.service.impl;
import net.xdclass.online_xdclass.config.CacheKeyManager;
import net.xdclass.online_xdclass.model.entity.Video;
import net.xdclass.online_xdclass.model.entity.VideoBanner;
import net.xdclass.online_xdclass.mapper.VideoMapper;
import net.xdclass.online_xdclass.service.VideoService;
import net.xdclass.online_xdclass.utils.BaseCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class VideoServiceImpl implements VideoService {
    @Autowired
    private VideoMapper videoMapper;
    @Autowired
    private BaseCache baseCache;
    @Override
    public List<Video> listVideo() {
        try{
            Object cacheObj =  baseCache.getTenMinuteCache().get(CacheKeyManager.INDEX_VIDEL_LIST,()->{
                List<Video> videoList = videoMapper.listVideo();
                return videoList;
            });
            if(cacheObj instanceof List){
                List<Video> videoList = (List<Video>)cacheObj;
                return videoList;
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        //可以返回兜底数据，业务系统降级-》SpringCloud专题课程
        return null;
    }
    @Override
    public List<VideoBanner> listBanner() {
        try{
            Object cacheObj =  baseCache.getTenMinuteCache().get(CacheKeyManager.INDEX_BANNER_KEY, ()->{
                List<VideoBanner> bannerList =  videoMapper.listVideoBanner();
                System.out.println("从数据库里面找轮播图列表");
                return bannerList;
            });
            if(cacheObj instanceof List){
                List<VideoBanner> bannerList = (List<VideoBanner>)cacheObj;
                return bannerList;
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }
    @Override
    public Video findDetailById(int videoId) {
        //单独构建一个缓存key，每个视频的key是不一样的
        String videoCacheKey = String.format(CacheKeyManager.VIDEO_DETAIL,videoId);
        try{
            Object cacheObject = baseCache.getOneHourCache().get( videoCacheKey, ()->{
                // 需要使用mybaits关联复杂查询
                Video video = videoMapper.findDetailById(videoId);
                return video;
            });
            if(cacheObject instanceof Video){
                Video video = (Video)cacheObject;
                return video;
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }
}
```

# 压力测试工具Jmeter5.X快速入门实战

## 接口压测和常用压力测试工具对比

- LoadRunner
  - 性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多

- Apache AB(单接口压测最方便)
  - 模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等

- Webbench
  - webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。
- Jmeter
  - 开源免费，功能强大，在互联网公司普遍使用
  - 压测不同的协议和应用 
    - Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …) 
    - SOAP / REST Webservices 
    - FTP 
    - Database via JDBC 
    - LDAP 轻量目录访问协议
    - Message-oriented middleware (MOM) via JMS 
    - Mail - SMTP(S), POP3(S) and IMAP(S) 
    - TCP等等

## 压测工具本地快速安装Jmeter5.x

- 需要安装JDK8 以上
  - 建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具
- 快速下载 https://jmeter.apache.org/download_jmeter.cgi
- 文档地址：http://jmeter.apache.org/usermanual/get-started.html

## Jmeter5.x目录文件讲解和汉化操作

目录

```
bin:核心可执行文件，包含配置
        jmeter.bat: windows启动文件(window系统一定要配置显示文件拓展名)
        jmeter: mac或者linux启动文件
        jmeter-server：mac或者Liunx分布式压测使用的启动文件
        jmeter-server.bat：window分布式压测使用的启动文件
        jmeter.properties: 核心配置文件   
extras：插件拓展的包

lib:核心的依赖包
```

Jmeter语言版本中英文切换

- 控制台修改 menu -> options -> choose language

配置文件修改

- bin目录 -> jmeter.properties
- 默认 #language=en
- 改为 language=zh_CN

 ## Jmeter5.X基础功能组件介绍线程组和Sampler

添加->threads->线程组（控制总体并发）

```
线程数：虚拟用户数。一个虚拟用户占用一个进程或线程

准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内 100个线程都要启动完成，每秒启动5个线程

循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环
```

线程组->添加-> Sampler(采样器) -> Http （一个线程组下面可以增加几个Sampler）

```
名称：采样器名称
注释：对这个采样器的描述
web服务器：
  默认协议是http
  默认端口是80
  服务器名称或IP ：请求的目标服务器名称或IP地址

路径：服务器URL
```

查看测试结果

```
线程组->添加->监听器->察看结果树
```

## Jmeter5.x实战之压测结果聚合报告分析

新增聚合报告：线程组->添加->监听器->聚合报告（Aggregate Report）

```
lable: sampler的名称
Samples: 一共发出去多少请求,例如10个用户，循环10次，则是 100
Average: 平均响应时间
Median: 中位数，也就是 50％ 用户的响应时间

90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time.     The remaining samples at least as long as this）
95% Line : 95％ 用户的响应不会超过该时间
99% Line : 99％ 用户的响应不会超过该时间
min : 最小响应时间
max : 最大响应时间

Error%：错误的请求的数量/请求的总数
Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps、tps
KB/Sec: 每秒接收数据量
```

# 实战接口压力测试，明白优化前后的QPS并发差距和跨域配置

## 开启Guava缓存压测热点数据接口

视频轮播图接口 Throughput: 14000

![image-20200422223934690](https://file.xdclass.net/note/2020/%E6%96%B0%E7%89%88ssm/%E5%9B%BE%E7%89%87/image-20200422223934690.png)

![image-20200422223910158](https://file.xdclass.net/note/2020/%E6%96%B0%E7%89%88ssm/%E5%9B%BE%E7%89%87/image-20200422223910158.png)

注意：接口的性能影响因素很多：机器的配置如CPU、内存、当前负载情况等，还有网络带宽因素影响，只能尽量减少影响因素

## 取消Guava缓存压测热点数据接口和前后对比

**不启用缓存 压测热点数据接口**

- 视频轮播图接口 Throughput : 2700

![image-20200422224833120](https://file.xdclass.net/note/2020/%E6%96%B0%E7%89%88ssm/%E5%9B%BE%E7%89%87/image-20200422224833120.png)

![image-20200422224740181](https://file.xdclass.net/note/2020/%E6%96%B0%E7%89%88ssm/%E5%9B%BE%E7%89%87/image-20200422224740181.png)

## SpringBoot2.X开启跨域配置

**什么是浏览器跨域和springboot怎么解决**

跨域：浏览器同源策略 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页"同源"。所谓"同源"指的是"三个相同"

```
协议相同  http https
域名相同  www.xdclass.net
端口相同  80  81

一句话：浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域

浏览器控制台跨域提示：
No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access.
```

- 解决方法

```
 1）JSONP
     2）Http响应头配置允许跨域
             nginx层配置 https://www.cnblogs.com/hawk-whu/p/6725699.html
     3）程序代码中处理 SpringBoot 通过拦截器配置
     
      //表示接受任意域名的请求,也可以指定域名
     response.setHeader("Access-Control-Allow-Origin", request.getHeader("origin"));
     
     //该字段可选，是个布尔值，表示是否可以携带cookie
     response.setHeader("Access-Control-Allow-Credentials", "true");
     
     response.setHeader("Access-Control-Allow-Methods", "GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS");
     
     response.setHeader("Access-Control-Allow-Headers", "*");
```

- options请求，这个需要注意
- 注意点: 假如接口报错，则跨域配置可能不生效（报错建议断点调试，排除异常错误）

# 互联网公司前端开发环境搭建之Node和Npm介绍

**搭建node环境和npm安装**

- 什么是NodeJS: Node.js 就是运行在服务端的 JavaScript

- 什么是npm: nodejs的包管理工具，可以下载使用公共仓库的包，类似maven 包安装分为本地安装（local）、全局安装（global）两种

  ```
  npm install express          # 本地安装express
  npm install express -g       # 全局安装express
  npm list -g                 #查看所有全局安装的模块
  ```

- Node安装包：http://nodejs.cn/download/

- 新版的nodejs已经集成了npm，所以npm也一并安装好

- 苹果系统Mac安装node和npm： brew install nodejs brew install npm

- Window安装node和npm 下载后一步步安装就行 参考文档：https://www.jianshu.com/p/03a76b2e7e00

- 验证是否成功

  ```
  node -v 
  ```

  ```
  npm -v 
  ```

## 切换npm镜像源为淘宝npm镜像

**修改npm镜像源为国内**

- 类似maven，从国外下载包很慢，所以就有人改成国内的maven仓库就会快很多，或者搭建自己本地的私服
- 国内直接使用 npm 的官方镜像是非常慢的，推荐使用淘宝 NPM 镜像。

淘宝 NPM 镜像是一个完整 npmjs.org 镜像，可以用此代替官方版本。

使用淘宝定制的 cnpm 命令行工具代替默认的 npm:(需要管理员权限)

```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

这样就可以使用 cnpm 命令来安装模块了：

```
cnpm install [name]
```

更多信息可以查阅：https://developer.aliyun.com/mirror/NPM

# 新版Vue + 脚手架Vue-Cli 4.3 安装

**本地搭建Vue 、CLI、Cube-UI相关框架**

- 什么是VUE 一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合. 文档：https://cn.vuejs.org/

  安装新版Vue (直接使用 cli)

  ```
  npm install vue (可以不用)
  ```

- 什么是VUE-CLI Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架

  安装 新版vue-cli

  ```
  cnpm install -g @vue/cli
  cnpm install -g @vue/cli-init
  ```

  使用vue-cli创建项目（测试项目，验证vue环境）

  ```
  vue create my-project
  ```

前端构建项目就到这里吧，太繁琐省略不写。。。

# 互联网公司 前端-后端项目云服务器生产环境部署核心知识

## 应用部署到可以公网访问需要的知识

- 一个http请求基本流程
  - 客户端通过发起域名资源请求 -> DNS解析获得IP -> 寻找服务器获得资源
- 域名和ip的关系，DNS作用
  - DNS：Domain Name Server 域名服务器 域名虽然便于人们记忆，但网络中的计算机之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器
- 什么是cname和a记录
  - a记录
    - 用户可以在此设置域名并指向到自己的目标主机地址上，从而实现通过域名找到服务器（也叫ip指向域名配置）
  - cname
    - 别名指向，可以为一个主机设置别名。比如设置open1024.com，用来指向一个主机 xdclass.net 那么以后就可以用open1024.com来代替访问 xdclass.net 了
    - [http://www.xdclass.net](http://www.xdclass.net/) --> xdclass.net
- 购买服务器，阿里云，腾讯云，亚马逊云aws
- 购买域名，备案
  - 阿里云 备案地址：https://beian.aliyun.com/
- 安装项目依赖的基本环境，比如java、nginx等软件(看项目)
- 配置域名解析到服务器
- 备注：后端项目一般部署Linux服务器，前端静态资源可以部署Linux也可以部署在CDN上

## 云服务器介绍和阿里云服务器ECS服务器选购

- 演示本地例子，部署阿里云
- 阿里云、腾讯云、亚马逊云 阿里云：https://www.aliyun.com/ 腾讯云：https://cloud.tencent.com/ 亚马逊云：https://aws.amazon.com/

- 阿里云新用户地址（如果地址失效，联系我或者客服即可） https://www.aliyun.com/minisite/goods?userCode=r5saexap&share_source=copy_link

## 阿里云服务器远程登录和常用工具

- 备注：(服务器、域名等使用你们自己购买的哈，上面有提供低价购买链接，失效找我)
  - 阿里云新用户地址 https://www.aliyun.com/minisite/goods?userCode=r5saexap&share_source=copy_link
- 控制台修改阿里云远程连接密码
- windows工具 putty，xshell, security 参考资料： https://jingyan.baidu.com/article/e75057f210c6dcebc91a89dd.html https://www.jb51.net/softjc/88235.html

- 苹果系统MAC ： 通过终端登录
  - ssh root@ip 回车后输入密码
  - ssh root@112.74.55.160
- linux图形操作工具（用于远程连接上传文件）
  - mac: filezilla
    - sftp://112.74.55.160
  - windows: winscp
  - 资料：https://jingyan.baidu.com/article/ed2a5d1f346fd409f6be179a.html

- 尝试自己通过百度进行找文档， 安装mysql jdk nginx maven git redis

# 生产环境Linux CentOS云服务器常见相关软件安装

## 阿里云Linux服务器Centos7 安装JDK8环境

**Linux云服务器安装JDK1.8**

- 官方地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

- 本地上传JDK1.8到服务器（课程提供安装包，对应章集的资料里面）

- 配置全局环境变量

  - 解压：tar -zxvf jdk-8u171-linux-x64.tar.gz

  - 重命名

  - vim /etc/profile

  - 配置

    ```
    JAVA_HOME=/usr/local/software/jdk1.8
    CLASSPATH=$JAVA_HOME/lib/
    PATH=$PATH:$JAVA_HOME/bin
    export PATH JAVA_HOME CLASSPATH
    ```

  - 环境变量立刻生效
    
    - source /etc/profile

- 查看安装情况 java -version

## 生产环境Linux服务器上Nginx介绍和安装

- 什么是Nginx服务器

  - 一个高性能的HTTP和反向代理web服务器

- 安装依赖

  - yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel

- 创建一个文件夹，上传本地提供的nginx包

  - tar -zxvf nginx-1.13.7.tar.gz 

    ```
    //执行命令
    ./configure
    make
    make install 
    ```

- 默认安装路径
  
- /usr/local/nginx
  
- 访问配置

  ```
  cd /usr/local/nginx/sbin   
  ./nginx
  ```

防火墙开放端口，阿里云网络安全组配置80端口

## 生产环境Linux服务器上Mysql安装和导入数据

- 安装Mysql 5.7 （注意，Mysql和系统务必保持一致，不然存在不一致）
- 开启mysql远程连接（如果是准线上，建议不要开启远程连接）
- 开放阿里云网络安全组配置 3306 端口
- 导入测试数据到Mysql

```
#下载mysql的Yum仓库
wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm

yum -y install mysql57-community-release-el7-10.noarch.rpm

#安装 mysql服务
yum -y install mysql-community-server

#启动数据库服务， systemctl 该命令可用于查看系统状态和管理系统及服务，centos7上开始使用
systemctl start  mysqld.service

#查看状态
systemctl status mysqld.service

#在日志文件中查看初始密码
grep "password" /var/log/mysqld.log

#进入修改Mysql密码

mysql -uroot -p

#新密码设置必须由大小写字母、数字和特殊符号组成
ALTER USER 'root'@'localhost' IDENTIFIED BY 'Xdclass.net168';

#开启mysql的远程访问， %是指全部
grant all privileges on *.* to 'root'@'%' identified by 'Xdclass.net168' with grant option;

#刷新权限
flush privileges; 
```

# 前端-后端集群部署线上Linux云服务器

## 前后端项目总体部署架构和阿里云域名解析A记录配置

**前端、后端项目总体部署架构和A记录配置**

- 后端接口地址 api.16web.net
  - 阿里云机器：112.74.55.160

- 前端接口地址 web.16web.net
  - 阿里云机器：112.74.55.160

- 前端部署nginx上
  - 后端部署多个节点，同过nginx反向代理做集群

## 后端Java API项目阿里云服务器部署安装

**SpringBoot项目部署阿里云服务器**

- 打包上传

  - 打包命令，各个系统通用，只要按照maven
  - mvn install -Dmaven.test.skip=true
    - 修改配置文件：数据库连接，账户密码

- 启动应用指定外部文件

- nohup java -jar -Dspring.config.location=./application.properties online_xdclass-0.0.1-SNAPSHOT.jar &

- 测试访问接口是否畅通

  ```
  curl 127.0.0.1:8089/api/v1/pub/video/list_banner
  
  112.74.55.160:8089/api/v1/pub/video/list_banner
  
  112.74.55.160:8088/api/v1/pub/video/list_banner
  ```

## 前后端分离-前端项目打包上传阿里云服务器

- 本地vue项目进行打包
  - cnpm run build

- 上传dist目录到Centos系统某个目录

## 线上部署之前端项目接入Nginx代理服务器

- 后端接口地址 api.16web.net
  - 阿里云机器：112.74.55.160

- 前端接口地址 web.16web.net
  - 阿里云机器：112.74.55.160

- 注意：配置A记录后不会立刻生效，且如果二次修改存在本地dns缓存，应该清除本地dns缓存，才可以访问

- 前端配置Nginx

```
location / {
        root   /usr/local/software/front_end/dist;
        index  index.html index.htm;
    }
```

- 重启nginx
  - ./nginx -s reload

## 高可用处理之后端API多节点集群部署

**springboot应用多节点部署和配置nginx访问**

- 多节点启动 节点1：112.74.55.160:8088 节点2：112.74.55.160:8089
- 配置nginx集群访问

```
upstream lbs {
   server 112.74.55.160:8089;
   server 112.74.55.160:8088;
}
 location /api/ {
    proxy_pass http://lbs;
    proxy_redirect default;
}
```

- 重启nginx命令
  - ./nginx -s reload